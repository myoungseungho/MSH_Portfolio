<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>콘솔 도구에서 배포까지 - 개발 도구 통합의 여정</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.8;
        }
        .container { max-width: 900px; margin: 0 auto; padding: 60px 20px; }
        .back-link {
            display: inline-block;
            margin-bottom: 24px;
            color: #666;
            text-decoration: none;
        }
        .back-link:hover { color: #111; }
        .header { margin-bottom: 48px; }
        .header h1 { font-size: 2.2rem; font-weight: 700; color: #111; margin-bottom: 12px; }
        .header p { color: #666; font-size: 1.1rem; }

        /* 여정 개요 */
        .journey-overview {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 16px;
            padding: 32px;
            margin-bottom: 48px;
            color: white;
        }
        .journey-overview h2 {
            font-size: 1.3rem;
            margin-bottom: 20px;
            opacity: 0.9;
        }
        .journey-flow {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 12px;
        }
        .journey-step {
            background: rgba(255,255,255,0.2);
            padding: 16px 20px;
            border-radius: 12px;
            text-align: center;
            flex: 1;
            min-width: 140px;
        }
        .journey-step .icon { font-size: 2rem; margin-bottom: 8px; }
        .journey-step .label { font-size: 0.9rem; font-weight: 600; }
        .journey-arrow {
            font-size: 1.5rem;
            opacity: 0.7;
        }

        /* 단계 섹션 */
        .stage {
            margin-bottom: 60px;
        }
        .stage-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 3px solid #667eea;
        }
        .stage-number {
            background: #667eea;
            color: white;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            font-weight: 700;
        }
        .stage-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #111;
        }

        /* 질문-답변 스타일 */
        .question-block {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 20px 24px;
            margin: 24px 0;
            border-radius: 0 12px 12px 0;
        }
        .question-block::before {
            content: "Q.";
            font-weight: 700;
            color: #ff9800;
            margin-right: 8px;
        }
        .question-block p {
            display: inline;
            font-size: 1.05rem;
            color: #333;
        }

        .answer-block {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 20px 24px;
            margin: 24px 0;
            border-radius: 0 12px 12px 0;
        }
        .answer-block::before {
            content: "A.";
            font-weight: 700;
            color: #2196f3;
            margin-right: 8px;
        }

        .insight-block {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            padding: 20px 24px;
            margin: 24px 0;
            border-radius: 0 12px 12px 0;
        }
        .insight-block::before {
            content: "핵심 개념:";
            font-weight: 700;
            color: #9c27b0;
            display: block;
            margin-bottom: 8px;
        }

        /* 개념 카드 */
        .concept-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            border: 1px solid #eee;
        }
        .concept-card h4 {
            color: #667eea;
            font-size: 1.1rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .concept-card p {
            color: #555;
            margin-bottom: 12px;
        }

        /* 코드 블록 */
        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 16px 0;
        }
        code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 0.9em;
            color: #e91e63;
        }

        /* 다이어그램 */
        .diagram {
            background: #fafafa;
            border: 2px dashed #ddd;
            border-radius: 12px;
            padding: 24px;
            margin: 20px 0;
            font-family: 'Consolas', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            white-space: pre;
            overflow-x: auto;
        }

        /* 비교 테이블 */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }
        .comparison-table th {
            background: #667eea;
            color: white;
            padding: 14px 16px;
            text-align: left;
            font-weight: 600;
        }
        .comparison-table td {
            padding: 14px 16px;
            border-bottom: 1px solid #eee;
        }
        .comparison-table tr:last-child td {
            border-bottom: none;
        }
        .comparison-table tr:hover {
            background: #f8f9ff;
        }

        /* 단계별 색상 */
        .stage-1 .stage-number, .stage-1 .stage-header { border-color: #4CAF50; }
        .stage-1 .stage-number { background: #4CAF50; }
        .stage-2 .stage-number, .stage-2 .stage-header { border-color: #FF9800; }
        .stage-2 .stage-number { background: #FF9800; }
        .stage-3 .stage-number, .stage-3 .stage-header { border-color: #2196F3; }
        .stage-3 .stage-number { background: #2196F3; }
        .stage-4 .stage-number, .stage-4 .stage-header { border-color: #9C27B0; }
        .stage-4 .stage-number { background: #9C27B0; }

        /* 요약 박스 */
        .summary-box {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8ec 100%);
            border-radius: 12px;
            padding: 28px;
            margin: 32px 0;
        }
        .summary-box h3 {
            color: #333;
            margin-bottom: 16px;
            font-size: 1.2rem;
        }
        .summary-box ul {
            list-style: none;
            padding: 0;
        }
        .summary-box li {
            padding: 8px 0;
            padding-left: 24px;
            position: relative;
        }
        .summary-box li::before {
            content: "✓";
            position: absolute;
            left: 0;
            color: #4CAF50;
            font-weight: bold;
        }

        .content-section {
            margin: 32px 0;
        }
        .content-section h3 {
            font-size: 1.2rem;
            color: #333;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #eee;
        }
        .content-section p {
            margin-bottom: 16px;
            color: #444;
        }

        .footer {
            margin-top: 60px;
            padding-top: 32px;
            border-top: 1px solid #eee;
            text-align: center;
            color: #999;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="../../" class="back-link">← 메인으로</a>

        <header class="header">
            <h1>콘솔 도구에서 배포까지</h1>
            <p>개발 도구 통합의 여정 - 왜 이런 과정을 거쳐야 하는가?</p>
        </header>

        <!-- 여정 개요 -->
        <div class="journey-overview">
            <h2>전체 여정</h2>
            <div class="journey-flow">
                <div class="journey-step">
                    <div class="icon">💻</div>
                    <div class="label">콘솔 도구</div>
                </div>
                <div class="journey-arrow">→</div>
                <div class="journey-step">
                    <div class="icon">🌐</div>
                    <div class="label">웹 서버</div>
                </div>
                <div class="journey-arrow">→</div>
                <div class="journey-step">
                    <div class="icon">🖥️</div>
                    <div class="label">Electron</div>
                </div>
                <div class="journey-arrow">→</div>
                <div class="journey-step">
                    <div class="icon">📦</div>
                    <div class="label">배포</div>
                </div>
            </div>
        </div>

        <!-- 시작: 문제 인식 -->
        <section class="stage stage-0">
            <div class="content-section">
                <h3>시작점: 불편함의 인식</h3>

                <p>당신은 게임 서버 개발자입니다. 업무 중에 여러 가지 도구들을 만들었어요:</p>

                <ul style="margin: 16px 0; padding-left: 24px;">
                    <li>MongoDB에서 데이터 추출하는 Python 스크립트</li>
                    <li>게임 서버에 명령 보내는 GM 도구</li>
                    <li>패킷 테스트하는 더미 클라이언트</li>
                </ul>

                <p>이 도구들은 각각 <strong>콘솔(터미널)</strong>에서 실행됩니다. 검은 화면에 하얀 글씨로.</p>

                <div class="question-block">
                    <p>그런데... 이게 불편해요. 뭐가 불편할까요?</p>
                </div>

                <div class="answer-block">
                    <p>매번 명령어 타이핑해야 하고, 결과가 텍스트로만 나오고, 다른 사람(기획자, QA)이 쓰기 어렵습니다.
                    그리고 도구마다 따로 실행해야 해서 창이 여러 개 뜹니다.</p>
                </div>

                <p>그래서 생각합니다:</p>
                <blockquote style="background: #f9f9f9; padding: 16px 20px; border-left: 4px solid #667eea; margin: 20px 0; font-style: italic;">
                    "버튼 클릭으로 실행되고, 예쁜 UI가 있고, 하나의 프로그램에서 다 관리되면 좋겠다.
                    그리고 다른 사람한테 쉽게 전달할 수 있으면 좋겠다."
                </blockquote>

                <p>이 목표를 이루려면, <strong>반드시 거쳐야 하는 개념들</strong>이 있습니다.</p>
            </div>
        </section>

        <!-- Stage 1: 콘솔 → 웹 -->
        <section class="stage stage-1">
            <div class="stage-header">
                <div class="stage-number">1</div>
                <h2 class="stage-title">콘솔에서 웹으로</h2>
            </div>

            <div class="content-section">
                <h3>왜 "웹"인가?</h3>

                <div class="question-block">
                    <p>콘솔 도구에 예쁜 UI를 붙이고 싶어요. 어떤 방법이 있을까요?</p>
                </div>

                <p>선택지가 있습니다:</p>
                <table class="comparison-table">
                    <tr>
                        <th>방법</th>
                        <th>설명</th>
                        <th>난이도</th>
                    </tr>
                    <tr>
                        <td>1. 네이티브 GUI</td>
                        <td>C++로 Windows 창 프로그램 (WinAPI, Qt 등)</td>
                        <td>어려움</td>
                    </tr>
                    <tr>
                        <td>2. Python GUI</td>
                        <td>Tkinter, PyQt 등</td>
                        <td>중간</td>
                    </tr>
                    <tr>
                        <td><strong>3. 웹 UI</strong></td>
                        <td>HTML/CSS/JavaScript로 브라우저에서</td>
                        <td>쉬움</td>
                    </tr>
                </table>

                <div class="answer-block">
                    <p><strong>웹 UI</strong>가 가장 쉽습니다. HTML/CSS로 예쁜 화면 만들기 쉽고, 브라우저만 있으면 어디서든 접근 가능하니까요.</p>
                </div>

                <div class="question-block">
                    <p>그런데 기존 콘솔 도구(Python, Node.js 스크립트)는 어떻게 되나요? 버리고 새로 만들어야 하나요?</p>
                </div>

                <div class="answer-block">
                    <p>아니요! 기존 로직은 그대로 두고, 앞에 <strong>"웹 서버"</strong>를 붙이면 됩니다.</p>
                </div>
            </div>

            <div class="content-section">
                <h3>핵심 개념: Client-Server (클라이언트-서버)</h3>

                <div class="insight-block">
                    <p><strong>Client-Server</strong>는 "요청하는 쪽"과 "응답하는 쪽"을 분리하는 구조입니다.</p>
                </div>

                <div class="diagram">
┌─────────────┐         HTTP 요청          ┌─────────────┐
│   Client    │  ───────────────────────→  │   Server    │
│  (브라우저)  │                            │  (웹 서버)   │
│             │  ←───────────────────────  │             │
└─────────────┘         HTTP 응답          └─────────────┘
                      (HTML, JSON 등)
                </div>

                <div class="concept-card">
                    <h4>Client (클라이언트)</h4>
                    <p>요청을 보내는 쪽. 여기서는 <strong>브라우저</strong>입니다.</p>
                    <p>사용자가 버튼을 클릭하면 → 브라우저가 서버에 요청을 보냅니다.</p>
                </div>

                <div class="concept-card">
                    <h4>Server (서버)</h4>
                    <p>요청을 받아서 처리하고 응답하는 쪽. 여기서는 <strong>웹 서버</strong>입니다.</p>
                    <p>당신의 기존 콘솔 도구 로직이 여기서 실행됩니다.</p>
                </div>

                <div class="question-block">
                    <p>왜 굳이 분리하나요? 하나로 만들면 안 되나요?</p>
                </div>

                <div class="answer-block">
                    <p>분리하면:</p>
                    <ul style="margin-top: 8px; padding-left: 20px;">
                        <li>여러 사람이 동시에 접속 가능 (클라이언트 여러 개)</li>
                        <li>UI와 로직을 독립적으로 수정 가능</li>
                        <li>다른 컴퓨터에서도 브라우저로 접근 가능</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <h3>핵심 개념: HTTP와 REST API</h3>

                <div class="question-block">
                    <p>클라이언트와 서버가 "대화"한다는데, 무슨 언어로 대화하나요?</p>
                </div>

                <div class="insight-block">
                    <p><strong>HTTP (HyperText Transfer Protocol)</strong>는 웹에서 클라이언트와 서버가 통신하는 약속(프로토콜)입니다.</p>
                </div>

                <p>HTTP에는 "동사"가 있습니다:</p>

                <table class="comparison-table">
                    <tr>
                        <th>HTTP 메서드</th>
                        <th>의미</th>
                        <th>예시</th>
                    </tr>
                    <tr>
                        <td>GET</td>
                        <td>데이터 조회 (읽기)</td>
                        <td>유저 목록 가져오기</td>
                    </tr>
                    <tr>
                        <td>POST</td>
                        <td>데이터 생성/전송</td>
                        <td>새 아이템 추가</td>
                    </tr>
                    <tr>
                        <td>PUT/PATCH</td>
                        <td>데이터 수정</td>
                        <td>유저 정보 변경</td>
                    </tr>
                    <tr>
                        <td>DELETE</td>
                        <td>데이터 삭제</td>
                        <td>아이템 삭제</td>
                    </tr>
                </table>

                <div class="concept-card">
                    <h4>REST API</h4>
                    <p>HTTP를 사용해서 데이터를 주고받는 방식의 설계 규칙입니다.</p>
                    <p>예를 들어:</p>
                    <pre>GET  /api/users         → 유저 목록 조회
GET  /api/users/123     → 123번 유저 조회
POST /api/users         → 새 유저 생성
DELETE /api/users/123   → 123번 유저 삭제</pre>
                </div>

                <p>당신의 웹 서버는 이런 API를 제공합니다:</p>
                <pre>GET  /api/tools/status   → 도구 상태 조회
POST /api/tools/mongoCsv/restart  → MongoDB 도구 재시작</pre>
            </div>

            <div class="content-section">
                <h3>핵심 개념: Frontend와 Backend</h3>

                <div class="diagram">
┌───────────────────────────────────────────────────────────────┐
│                        웹 애플리케이션                          │
│                                                               │
│   ┌─────────────────────┐      ┌─────────────────────┐       │
│   │     Frontend        │      │      Backend        │       │
│   │    (프론트엔드)       │      │     (백엔드)         │       │
│   │                     │      │                     │       │
│   │  - HTML (구조)       │      │  - 비즈니스 로직     │       │
│   │  - CSS (스타일)      │ ───→ │  - 데이터베이스 접근  │       │
│   │  - JavaScript (동작) │ ←─── │  - 파일 처리         │       │
│   │                     │      │  - 외부 API 호출     │       │
│   │  "보이는 부분"        │      │  "보이지 않는 부분"   │       │
│   └─────────────────────┘      └─────────────────────┘       │
└───────────────────────────────────────────────────────────────┘
                </div>

                <div class="concept-card">
                    <h4>Frontend (프론트엔드)</h4>
                    <p>사용자가 보고 상호작용하는 부분입니다.</p>
                    <p>브라우저에서 실행되는 HTML, CSS, JavaScript 코드입니다.</p>
                </div>

                <div class="concept-card">
                    <h4>Backend (백엔드)</h4>
                    <p>사용자 눈에 보이지 않는 서버 측 로직입니다.</p>
                    <p>당신의 기존 콘솔 도구 로직(Python, Node.js)이 여기 해당합니다.</p>
                </div>

                <div class="answer-block">
                    <p>결국: <strong>기존 콘솔 도구 = Backend</strong>, <strong>새로 만든 웹 UI = Frontend</strong>입니다.</p>
                </div>
            </div>

            <div class="summary-box">
                <h3>1단계 요약: 콘솔 → 웹</h3>
                <ul>
                    <li><strong>Client-Server</strong>: 요청(브라우저)과 응답(서버) 분리</li>
                    <li><strong>HTTP/REST API</strong>: 둘이 대화하는 약속</li>
                    <li><strong>Frontend</strong>: 예쁜 UI (HTML/CSS/JS)</li>
                    <li><strong>Backend</strong>: 기존 도구 로직</li>
                </ul>
            </div>
        </section>

        <!-- Stage 2: 여러 웹 도구 → Electron 통합 -->
        <section class="stage stage-2">
            <div class="stage-header">
                <div class="stage-number">2</div>
                <h2 class="stage-title">여러 도구를 하나로 통합</h2>
            </div>

            <div class="content-section">
                <h3>새로운 문제 발생</h3>

                <p>이제 각 도구에 웹 UI가 생겼습니다. 근데...</p>

                <div class="diagram">
브라우저 탭 1: http://localhost:3000  → MongoDB CSV 도구
브라우저 탭 2: http://localhost:8847  → GM 도구
브라우저 탭 3: http://localhost:5000  → Packet Sender
                </div>

                <div class="question-block">
                    <p>여전히 도구마다 따로 실행해야 하고, 탭이 여러 개예요. 뭐가 문제일까요?</p>
                </div>

                <div class="answer-block">
                    <p>하나의 "통합 대시보드"가 필요합니다. 모든 도구를 한 곳에서 관리하고, 하나의 프로그램처럼 실행되면 좋겠어요.</p>
                </div>
            </div>

            <div class="content-section">
                <h3>Electron이란?</h3>

                <div class="question-block">
                    <p>웹 기술(HTML/CSS/JS)로 만든 UI를, 브라우저 없이 "데스크톱 앱"처럼 실행할 수 없을까요?</p>
                </div>

                <div class="insight-block">
                    <p><strong>Electron</strong>은 웹 기술로 데스크톱 앱을 만들 수 있게 해주는 프레임워크입니다.</p>
                </div>

                <div class="concept-card">
                    <h4>Electron의 구조</h4>
                    <p>Electron 앱 안에는 두 가지가 들어있습니다:</p>
                    <pre>Electron 앱 (예: ChosunToolbox.exe)
├── Chromium (크로미움) → 웹 페이지를 렌더링하는 브라우저 엔진
└── Node.js            → JavaScript로 시스템 기능(파일, 프로세스 등) 사용</pre>
                    <p style="margin-top: 12px;">즉, <strong>브라우저를 앱 안에 내장</strong>한 것입니다!</p>
                </div>

                <p>VS Code, Discord, Slack 같은 유명한 앱들도 Electron으로 만들어졌습니다.</p>
            </div>

            <div class="content-section">
                <h3>핵심 개념: Process Spawning (프로세스 생성)</h3>

                <div class="question-block">
                    <p>Electron 앱(대시보드)이 다른 도구들(Python 서버, Node 서버)을 어떻게 실행하나요?</p>
                </div>

                <div class="insight-block">
                    <p><strong>Process Spawning</strong>은 하나의 프로그램이 다른 프로그램을 실행시키는 것입니다.</p>
                </div>

                <div class="diagram">
┌────────────────────────────────────────────────────────────┐
│              ChosunToolbox.exe (부모 프로세스)               │
│                                                            │
│   spawn('python', ['server.py'])  ──→  Python 서버 프로세스 │
│   spawn('node', ['server.js'])    ──→  Node.js 서버 프로세스│
│                                                            │
└────────────────────────────────────────────────────────────┘
                </div>

                <p>코드로 보면:</p>
                <pre>const { spawn } = require('child_process');

// Python 서버 실행
const pythonServer = spawn('python', ['server.py'], {
    cwd: './gm_tool'  // 이 폴더에서 실행
});

// Node.js 서버 실행
const nodeServer = spawn('node', ['server.js'], {
    cwd: './mongo_csv_tool'
});</pre>

                <div class="concept-card">
                    <h4>부모 프로세스 vs 자식 프로세스</h4>
                    <p><strong>부모</strong>: 다른 프로그램을 실행시킨 쪽 (Electron 앱)</p>
                    <p><strong>자식</strong>: 실행된 쪽 (Python 서버, Node 서버)</p>
                    <p>부모가 종료되면 자식도 함께 정리해야 합니다.</p>
                </div>
            </div>

            <div class="content-section">
                <h3>핵심 개념: Orchestration (오케스트레이션)</h3>

                <div class="question-block">
                    <p>여러 프로세스를 실행하는 것까지는 알겠는데, 관리는 어떻게 하나요?</p>
                </div>

                <div class="insight-block">
                    <p><strong>Orchestration</strong>은 여러 서비스/프로세스를 조율하고 관리하는 것입니다.</p>
                </div>

                <p>오케스트라의 지휘자처럼, Electron 앱이 다음을 담당합니다:</p>

                <ul style="padding-left: 24px; margin: 16px 0;">
                    <li><strong>시작</strong>: 앱 실행 시 모든 도구 서버 자동 시작</li>
                    <li><strong>상태 모니터링</strong>: 각 도구가 정상 작동 중인지 확인</li>
                    <li><strong>재시작</strong>: 문제 생기면 특정 도구만 재시작</li>
                    <li><strong>종료</strong>: 앱 종료 시 모든 자식 프로세스 정리</li>
                </ul>

                <div class="diagram">
┌─────────────────────────────────────────────────────────┐
│                    Electron Dashboard                    │
│                      (오케스트레이터)                      │
│                                                         │
│   ┌─────────┐   ┌─────────┐   ┌─────────┐             │
│   │ 도구 A  │   │ 도구 B  │   │ 도구 C  │             │
│   │ :3000   │   │ :8847   │   │ :5000   │             │
│   │   ✓     │   │   ✓     │   │   ✗     │ ← 문제 감지  │
│   └─────────┘   └─────────┘   └────┬────┘             │
│                                    │                   │
│                              자동 재시작               │
└─────────────────────────────────────────────────────────┘
                </div>
            </div>

            <div class="content-section">
                <h3>핵심 개념: IPC (Inter-Process Communication)</h3>

                <div class="question-block">
                    <p>부모 프로세스(Electron)와 자식 프로세스(도구 서버)가 서로 정보를 주고받으려면?</p>
                </div>

                <div class="insight-block">
                    <p><strong>IPC (Inter-Process Communication)</strong>는 프로세스 간에 데이터를 주고받는 방법입니다.</p>
                </div>

                <p>방법은 여러 가지가 있습니다:</p>

                <table class="comparison-table">
                    <tr>
                        <th>방법</th>
                        <th>설명</th>
                        <th>사용 예</th>
                    </tr>
                    <tr>
                        <td>HTTP 통신</td>
                        <td>REST API로 요청/응답</td>
                        <td>대시보드 → 도구 서버</td>
                    </tr>
                    <tr>
                        <td>stdout/stderr</td>
                        <td>자식 프로세스의 출력 읽기</td>
                        <td>로그 메시지 수집</td>
                    </tr>
                    <tr>
                        <td>Electron IPC</td>
                        <td>Main ↔ Renderer 통신</td>
                        <td>UI와 Node.js 로직 연결</td>
                    </tr>
                </table>

                <p>당신의 앱에서는 주로 <strong>HTTP 통신</strong>을 사용합니다. 대시보드가 각 도구 서버에 HTTP 요청을 보내서 상태를 확인하거나 명령을 내립니다.</p>
            </div>

            <div class="summary-box">
                <h3>2단계 요약: 여러 도구 → 통합</h3>
                <ul>
                    <li><strong>Electron</strong>: 웹 기술로 데스크톱 앱 만들기 (Chromium + Node.js 내장)</li>
                    <li><strong>Process Spawning</strong>: 프로그램이 다른 프로그램 실행</li>
                    <li><strong>Orchestration</strong>: 여러 프로세스를 조율/관리</li>
                    <li><strong>IPC</strong>: 프로세스 간 통신</li>
                </ul>
            </div>
        </section>

        <!-- Stage 3: 실행 파일 만들기 -->
        <section class="stage stage-3">
            <div class="stage-header">
                <div class="stage-number">3</div>
                <h2 class="stage-title">실행 파일 만들기</h2>
            </div>

            <div class="content-section">
                <h3>개발 환경 vs 배포</h3>

                <p>지금까지는 개발 환경에서 실행했습니다:</p>
                <pre>npm start  // 또는 electron .</pre>

                <div class="question-block">
                    <p>이 상태로 다른 사람에게 전달할 수 있나요?</p>
                </div>

                <div class="answer-block">
                    <p>안 됩니다. 상대방 PC에 Node.js도 설치해야 하고, 소스 코드 전체도 전달해야 하고,
                    npm install도 실행해야 합니다. 너무 복잡해요.</p>
                </div>

                <p>그래서 <strong>.exe 파일</strong>로 만들어야 합니다. 더블클릭만 하면 실행되도록.</p>
            </div>

            <div class="content-section">
                <h3>핵심 개념: Bundling (번들링)</h3>

                <div class="question-block">
                    <p>프로젝트에 파일이 수십~수백 개인데, 이걸 어떻게 하나로 만드나요?</p>
                </div>

                <div class="insight-block">
                    <p><strong>Bundling</strong>은 여러 파일을 분석해서 하나(또는 적은 수)의 파일로 합치는 것입니다.</p>
                </div>

                <div class="diagram">
번들링 전:                          번들링 후:
├── main.js
├── utils/
│   ├── helper.js        ──────→   bundle.js (하나의 파일)
│   └── config.js
├── components/
│   ├── button.js
│   └── modal.js
                </div>

                <div class="concept-card">
                    <h4>Dependency Graph (의존성 그래프)</h4>
                    <p>번들러가 가장 먼저 하는 일은 "누가 누구를 필요로 하는지" 파악하는 것입니다.</p>
                    <pre>main.js
  └── require('./utils/helper.js')
        └── require('./utils/config.js')
  └── require('./components/button.js')</pre>
                    <p style="margin-top: 12px;">이 관계도를 따라가면서, 필요한 파일만 순서대로 합칩니다.</p>
                </div>

                <div class="question-block">
                    <p>그냥 파일들을 복사해서 붙이면 안 되나요?</p>
                </div>

                <div class="answer-block">
                    <p>안 됩니다. 순서가 중요합니다.</p>
                    <p><code>button.js</code>가 <code>helper.js</code>를 사용한다면, <code>helper.js</code>가 먼저 있어야 합니다.
                    의존성 그래프를 분석해야 올바른 순서를 알 수 있습니다.</p>
                </div>
            </div>

            <div class="content-section">
                <h3>핵심 개념: Embedding (임베딩)</h3>

                <div class="question-block">
                    <p>JS 코드는 합쳤는데... 이미지, 아이콘 같은 리소스는 어디로 가나요?</p>
                </div>

                <div class="insight-block">
                    <p><strong>Embedding</strong>은 코드가 아닌 리소스(이미지, 설정 파일 등)를 실행 파일 안에 넣는 것입니다.</p>
                </div>

                <p>EXE 파일의 실제 구조를 보면:</p>

                <div class="diagram">
MyApp.exe (PE 파일 포맷)
┌─────────────────────┐
│   PE Header         │  ← 파일 정보, 메모리 매핑 정보
├─────────────────────┤
│   .text (코드)      │  ← 실행할 명령어들
├─────────────────────┤
│   .data (데이터)    │  ← 전역 변수, 상수
├─────────────────────┤
│   .rsrc (리소스)    │  ← 아이콘, 이미지, 문자열 등
└─────────────────────┘
                </div>

                <p>Windows EXE 파일에는 <code>.rsrc</code> 섹션이 있어서, 리소스를 안에 넣을 수 있습니다.</p>

                <div class="concept-card">
                    <h4>Electron의 방식: ASAR 아카이브</h4>
                    <p>Electron은 조금 다릅니다. 모든 소스와 리소스를 <code>.asar</code> 파일로 압축해서 EXE 안에 넣습니다.</p>
                    <pre>ChosunToolbox.exe
└── 내부에 app.asar (압축된 가상 파일 시스템)
    ├── main.js
    ├── preload.js
    ├── dashboard/
    │   └── index.html
    └── assets/
        └── icon.ico</pre>
                    <p style="margin-top: 12px;">실행 시 이 가상 파일 시스템에서 파일을 읽어옵니다.</p>
                </div>
            </div>

            <div class="content-section">
                <h3>핵심 개념: Runtime Embedding (런타임 임베딩)</h3>

                <div class="question-block">
                    <p>JavaScript 코드를 실행하려면 Node.js가 필요한데, 상대방 PC에 Node.js가 없으면요?</p>
                </div>

                <div class="insight-block">
                    <p><strong>Runtime Embedding</strong>은 코드를 실행하는 데 필요한 런타임(실행 환경) 자체를 앱 안에 포함하는 것입니다.</p>
                </div>

                <div class="diagram">
일반 Node.js 앱:                    Electron 앱:

[사용자 PC에 Node.js 필요]          [Node.js가 앱 안에 포함됨]

npm install                        그냥 exe 더블클릭
node app.js
                </div>

                <p>Electron 앱이 67MB나 되는 이유:</p>

                <table class="comparison-table">
                    <tr>
                        <th>구성 요소</th>
                        <th>대략적 크기</th>
                    </tr>
                    <tr>
                        <td>Chromium (브라우저 엔진)</td>
                        <td>~50MB</td>
                    </tr>
                    <tr>
                        <td>Node.js (런타임)</td>
                        <td>~15MB</td>
                    </tr>
                    <tr>
                        <td>실제 앱 코드</td>
                        <td>~2MB</td>
                    </tr>
                    <tr>
                        <td><strong>합계</strong></td>
                        <td><strong>~67MB</strong></td>
                    </tr>
                </table>

                <div class="answer-block">
                    <p>브라우저 하나가 통째로 들어있는 것입니다. 덕분에 사용자는 아무것도 설치할 필요 없이 exe만 실행하면 됩니다.</p>
                </div>
            </div>

            <div class="summary-box">
                <h3>3단계 요약: 실행 파일 만들기</h3>
                <ul>
                    <li><strong>Bundling</strong>: 여러 소스 파일을 하나로 합침 (의존성 그래프 분석)</li>
                    <li><strong>Embedding</strong>: 리소스(이미지 등)를 EXE 안에 포함</li>
                    <li><strong>Runtime Embedding</strong>: 실행 환경(Node.js, Chromium)까지 포함</li>
                </ul>
            </div>
        </section>

        <!-- Stage 4: 배포 -->
        <section class="stage stage-4">
            <div class="stage-header">
                <div class="stage-number">4</div>
                <h2 class="stage-title">배포하기</h2>
            </div>

            <div class="content-section">
                <h3>EXE 하나로 충분할까?</h3>

                <div class="question-block">
                    <p>ChosunToolbox.exe를 만들었습니다. 이것만 전달하면 될까요?</p>
                </div>

                <div class="answer-block">
                    <p>경우에 따라 다릅니다. 두 가지 개념을 구분해야 합니다:</p>
                </div>

                <div class="concept-card">
                    <h4>Build-time Dependency (빌드 타임 의존성)</h4>
                    <p>빌드할 때 EXE 안에 포함되는 것들</p>
                    <p>→ 이것들은 EXE 안에 있으므로 따로 전달할 필요 없음</p>
                    <pre>예: main.js, dashboard HTML, 아이콘 등</pre>
                </div>

                <div class="concept-card">
                    <h4>Runtime Dependency (런타임 의존성)</h4>
                    <p>앱이 실행될 때 필요한 외부 파일/프로그램</p>
                    <p>→ 이것들은 EXE와 함께 있어야 함</p>
                    <pre>예: config.json, 외부 스크립트, Python 인터프리터 등</pre>
                </div>

                <p>당신의 앱을 분석하면:</p>

                <div class="diagram">
ChosunToolbox.exe (빌드 타임 의존성 - EXE 안에 있음)
├── Chromium, Node.js (런타임 임베딩)
├── main.js, preload.js
├── dashboard/ (HTML, CSS, JS)
└── assets/ (아이콘)

런타임 의존성 (EXE 외부에 있어야 함):
├── config.json
├── MongoDB CSV 추출도구 v3/  ← Python/Node 스크립트
├── gm_tool/
├── packet_sender/
└── character_copy/

시스템 의존성 (사용자 PC에 설치 필요):
├── Python
└── Node.js (일부 도구용)
                </div>
            </div>

            <div class="content-section">
                <h3>Self-Contained (자기 완결형) vs 의존성 분리</h3>

                <table class="comparison-table">
                    <tr>
                        <th>방식</th>
                        <th>장점</th>
                        <th>단점</th>
                    </tr>
                    <tr>
                        <td><strong>Self-Contained</strong><br>(모든 것을 EXE에)</td>
                        <td>파일 하나만 전달<br>설치 불필요</td>
                        <td>용량 매우 큼<br>빌드 복잡</td>
                    </tr>
                    <tr>
                        <td><strong>의존성 분리</strong><br>(현재 방식)</td>
                        <td>용량 적정<br>유연함</td>
                        <td>폴더째 전달 필요<br>설치 가이드 필요</td>
                    </tr>
                </table>
            </div>

            <div class="content-section">
                <h3>실무에서의 배포 형태</h3>

                <div class="concept-card">
                    <h4>1. ZIP + README (가장 흔함)</h4>
                    <pre>ChosunTools_v1.0.zip
├── tools/
│   ├── ChosunToolbox/
│   ├── gm_tool/
│   └── ...
└── README.txt  ← "Python 3.x 필요, Node.js 필요"</pre>
                    <p>간단하지만, 사용자가 직접 Python/Node 설치해야 함</p>
                </div>

                <div class="concept-card">
                    <h4>2. Portable 런타임 포함</h4>
                    <pre>ChosunTools_v1.0.zip
├── tools/
├── python/      ← Python Embedded (15MB)
├── node/        ← Node.js 바이너리 (30MB)
└── 실행.bat     ← 포터블 런타임 사용</pre>
                    <p>사용자 PC에 아무것도 설치 안 해도 됨. 용량 증가.</p>
                </div>

                <div class="concept-card">
                    <h4>3. 설치 프로그램 (Installer)</h4>
                    <pre>ChosunTools_Setup.exe
  → 더블클릭하면:
    1. 폴더 생성
    2. 파일 복사
    3. 바로가기 생성
    4. (선택) Python/Node 자동 설치</pre>
                    <p>전문적인 느낌. Inno Setup, NSIS 같은 도구로 제작.</p>
                </div>
            </div>

            <div class="summary-box">
                <h3>4단계 요약: 배포</h3>
                <ul>
                    <li><strong>Build-time vs Runtime Dependency</strong>: 어떤 건 EXE 안에, 어떤 건 밖에</li>
                    <li><strong>Self-Contained</strong>: 모든 걸 포함 (용량 큼, 편리함)</li>
                    <li><strong>배포 형태</strong>: ZIP, Portable 런타임 포함, Installer 등</li>
                </ul>
            </div>
        </section>

        <!-- 전체 요약 -->
        <section class="stage">
            <div class="stage-header">
                <div class="stage-number" style="background: #333;">!</div>
                <h2 class="stage-title">전체 요약: 거쳐온 개념들</h2>
            </div>

            <div class="diagram" style="font-size: 0.8rem;">
목표: "콘솔 도구들을 예쁘게 통합해서 다른 사람에게 쉽게 전달하고 싶다"

┌─────────────────────────────────────────────────────────────────────────┐
│  1단계: 콘솔 → 웹                                                        │
│  ─────────────────                                                       │
│  Client-Server    요청/응답 분리                                         │
│  HTTP/REST API    통신 약속                                              │
│  Frontend         UI (HTML/CSS/JS)                                       │
│  Backend          로직 (기존 도구)                                        │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  2단계: 여러 도구 → 통합                                                  │
│  ─────────────────────                                                   │
│  Electron              웹 기술로 데스크톱 앱                              │
│  Process Spawning      다른 프로그램 실행                                 │
│  Orchestration         여러 프로세스 관리                                 │
│  IPC                   프로세스 간 통신                                   │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  3단계: 실행 파일                                                         │
│  ───────────────                                                         │
│  Bundling              여러 파일 → 하나로                                 │
│  Dependency Graph      의존 관계 분석                                     │
│  Embedding             리소스를 EXE 안에                                  │
│  Runtime Embedding     런타임(Node.js 등)도 포함                          │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  4단계: 배포                                                              │
│  ──────────                                                              │
│  Build-time Dependency    빌드 시 포함되는 것                             │
│  Runtime Dependency       실행 시 필요한 것                               │
│  Self-Contained           모든 걸 포함한 단일 파일                        │
│  배포 형태                 ZIP, Installer, Portable 등                   │
└─────────────────────────────────────────────────────────────────────────┘
            </div>

            <div class="content-section" style="margin-top: 32px;">
                <p>이 개념들을 알면:</p>
                <ul style="padding-left: 24px;">
                    <li><strong>문제 해결</strong>: "왜 안 되지?" → 어느 레이어의 문제인지 파악 가능</li>
                    <li><strong>의사소통</strong>: 다른 개발자와 정확한 용어로 대화 가능</li>
                    <li><strong>확장</strong>: 새 기능 추가할 때 어디를 수정해야 하는지 명확</li>
                    <li><strong>도구 선택</strong>: 새 프로젝트에서 적합한 도구/방식 선택 가능</li>
                </ul>
            </div>
        </section>

        <footer class="footer">
            <p>게임 서버 개발자의 도구 통합 여정 - 콘솔에서 배포까지</p>
        </footer>
    </div>
</body>
</html>
