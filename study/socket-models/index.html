<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>소켓 I/O 모델: 동기부터 IOCP까지 - MSH Portfolio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.8;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 60px 20px;
        }

        .nav {
            margin-bottom: 40px;
        }

        .nav a {
            color: #666;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .nav a:hover {
            color: #333;
        }

        .header {
            margin-bottom: 50px;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 16px;
            color: #111;
        }

        .header-meta {
            display: flex;
            gap: 20px;
            color: #666;
            font-size: 0.9rem;
        }

        .section {
            margin-bottom: 50px;
        }

        .section h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #111;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .section h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 30px 0 15px 0;
            color: #333;
        }

        .section p {
            margin-bottom: 16px;
            color: #444;
        }

        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }

        pre code {
            background: none;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }

        th, td {
            padding: 14px 16px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background: #f8f8f8;
            font-weight: 600;
            color: #333;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .question-box {
            background: #fff8e1;
            border-left: 4px solid #ff9800;
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin: 20px 0;
        }

        .question-box h4 {
            color: #e65100;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .question-box p {
            margin-bottom: 0;
            color: #5d4037;
        }

        .answer-box {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin: 20px 0;
        }

        .answer-box h4 {
            color: #2e7d32;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .answer-box p {
            margin-bottom: 0;
            color: #1b5e20;
        }

        .insight-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin: 20px 0;
        }

        .insight-box h4 {
            color: #1565c0;
            margin-bottom: 10px;
        }

        .insight-box p {
            color: #0d47a1;
            margin-bottom: 8px;
        }

        .insight-box p:last-child {
            margin-bottom: 0;
        }

        .problem-box {
            background: #ffebee;
            border-left: 4px solid #f44336;
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin: 20px 0;
        }

        .problem-box h4 {
            color: #c62828;
            margin-bottom: 10px;
        }

        .problem-box p {
            color: #b71c1c;
            margin-bottom: 0;
        }

        ul, ol {
            margin: 16px 0;
            padding-left: 24px;
        }

        li {
            margin-bottom: 8px;
        }

        .diagram {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 24px;
            margin: 20px 0;
            font-family: 'Consolas', monospace;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.4;
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 20px 0;
        }

        .tag {
            background: #e8f4fd;
            color: #1976d2;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .footer {
            text-align: center;
            padding: 40px 0;
            color: #999;
            font-size: 0.9rem;
            border-top: 1px solid #e0e0e0;
            margin-top: 60px;
        }

        .summary-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
        }

        .summary-box h3 {
            color: white;
            margin-top: 0;
            font-size: 1.3rem;
        }

        .summary-box p {
            color: rgba(255,255,255,0.9);
            margin-bottom: 12px;
        }

        .summary-box code {
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .demo-gif {
            width: 100%;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .step-number {
            display: inline-block;
            width: 28px;
            height: 28px;
            background: #2196f3;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 28px;
            font-weight: 600;
            margin-right: 10px;
        }

        .comparison-table {
            margin: 30px 0;
        }

        .comparison-table th {
            text-align: center;
        }

        .comparison-table td {
            text-align: center;
        }

        .comparison-table td:first-child {
            text-align: left;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav">
            <a href="../../">&larr; 돌아가기</a>
        </nav>

        <header class="header">
            <h1>소켓 I/O 모델: 동기부터 IOCP까지</h1>
            <div class="header-meta">
                <span>네트워크 프로그래밍 기초</span>
                <span>2025.01</span>
            </div>
            <div class="tags">
                <span class="tag">Socket</span>
                <span class="tag">동기/비동기</span>
                <span class="tag">Overlapped I/O</span>
                <span class="tag">IOCP</span>
                <span class="tag">Windows</span>
            </div>
        </header>

        <!-- 개요 -->
        <section class="section">
            <h2>개요</h2>
            <p>
                게임 서버를 만들다 보면 "IOCP를 써야 한다"는 말을 듣게 됩니다.
                IOCP가 뭔지, 왜 필요한지, 어떻게 동작하는지를 <strong>질문과 답변 형식</strong>으로
                차근차근 이해해봅시다.
            </p>
            <p>
                이 문서는 "프로그램끼리 어떻게 대화할까?"라는 아주 기초적인 질문에서 시작해서,
                고성능 서버의 핵심인 IOCP까지 단계별로 쌓아갑니다.
            </p>
        </section>

        <!-- 1. 소켓의 시작 -->
        <section class="section">
            <h2>1. 프로그램끼리의 대화 - 소켓</h2>

            <div class="question-box">
                <h4>질문</h4>
                <p>컴퓨터 A에서 게임 클라이언트가 실행 중이고, 컴퓨터 B에서 게임 서버가 실행 중입니다. 두 프로그램이 서로 다른 컴퓨터에 있는데, 어떻게 "대화"를 할 수 있을까요?</p>
            </div>

            <div class="answer-box">
                <h4>답</h4>
                <p>전화처럼 연결해서 대화한다!</p>
            </div>

            <p>정확합니다! 전화 통화의 특징을 생각해보면:</p>
            <ul>
                <li>서로 <strong>연결</strong>이 되어야 대화 가능</li>
                <li>한쪽이 말하면 다른 쪽이 듣고, 반대도 가능 (양방향)</li>
                <li>연결이 끊어지면 대화 끝</li>
            </ul>

            <p>네트워크 프로그래밍도 정확히 이렇게 동작합니다!</p>

            <div class="question-box">
                <h4>질문</h4>
                <p>현실에서 전화를 걸려면 "전화기"와 "전화번호"가 필요합니다. 프로그램 세계에서는 뭐가 필요할까요?</p>
            </div>

            <div class="answer-box">
                <h4>답</h4>
                <p>소켓(Socket)이랑 IP 주소 + 포트!</p>
            </div>

            <table>
                <tr>
                    <th>현실 (전화)</th>
                    <th>프로그램 세계</th>
                </tr>
                <tr>
                    <td>전화기</td>
                    <td><strong>소켓 (Socket)</strong></td>
                </tr>
                <tr>
                    <td>전화번호</td>
                    <td><strong>IP 주소 + 포트</strong></td>
                </tr>
            </table>

            <div class="insight-box">
                <h4>왜 IP 주소만으로는 부족할까?</h4>
                <p>한 컴퓨터에서 카카오톡, 크롬, 게임이 동시에 실행 중일 때, IP 주소만으로는 <strong>어느 프로그램</strong>한테 데이터를 전달할지 알 수 없습니다.</p>
                <p><code>IP 주소</code> = 건물 주소 (어느 컴퓨터인지)</p>
                <p><code>포트</code> = 호수 (그 컴퓨터의 어느 프로그램인지)</p>
            </div>
        </section>

        <!-- 2. 동기의 개념 -->
        <section class="section">
            <h2>2. 동기(Synchronous)란?</h2>

            <p>현실에서 전화 통화를 하려면 이런 순서로 진행되죠:</p>

            <div class="diagram">1. 전화기를 든다
2. 번호를 누른다
3. 상대가 받을 때까지 기다린다... (뚜르르... 뚜르르...)
4. 상대가 받으면 → 대화 시작!</div>

            <div class="question-box">
                <h4>질문</h4>
                <p>3번 단계에서 "상대가 받을 때까지 기다린다"고 했습니다. 이때 나는 다른 일을 할 수 있나요? 아니면 전화기 붙들고 가만히 기다려야 하나요?</p>
            </div>

            <div class="answer-box">
                <h4>답</h4>
                <p>기다리는 동안은 아무것도 못하지 않나?</p>
            </div>

            <p>맞습니다! 바로 이게 <strong>"동기(Synchronous)"</strong>입니다.</p>

            <div class="insight-box">
                <h4>동기 = 기다린다</h4>
                <p>전화 거는 동안 → 가만히 기다림 (다른 일 못 함)</p>
                <p>상대가 받으면 → 그제야 다음 단계로 진행</p>
            </div>

            <pre><code>// 동기 소켓 코드
connect(socket, serverAddr, ...);  // 서버에 연결 요청
// ↑ 여기서 멈춤! 연결될 때까지 다음 줄로 안 넘어감

send(socket, data, ...);           // 연결되면 그제야 실행됨</code></pre>

            <p><code>connect()</code> 함수가 <strong>완료될 때까지</strong> 프로그램이 그 자리에서 <strong>멈춰있는 것</strong> = <strong>동기 방식</strong></p>
        </section>

        <!-- 3. 동기의 문제점 -->
        <section class="section">
            <h2>3. 동기 방식의 문제점</h2>

            <p>자, 이제 <strong>서버</strong> 입장에서 생각해봅시다.</p>

            <div class="question-box">
                <h4>상황</h4>
                <p>게임 서버가 실행 중입니다. 플레이어 A가 접속했고, 서버가 A의 요청을 처리하는 중입니다... (동기 방식이라 기다리는 중)</p>
                <p><strong>이때 플레이어 B가 접속을 시도합니다. B는 어떻게 될까요?</strong></p>
            </div>

            <div class="answer-box">
                <h4>답</h4>
                <p>B도 계속 기다려야 하지 않나?</p>
            </div>

            <div class="problem-box">
                <h4>동기 방식의 치명적인 문제</h4>
                <p><strong>동기 서버 = 한 번에 한 명만 상대 가능</strong></p>
                <p>게임 서버에 1000명이 접속하면? → 999명이 줄 서서 기다림 → 서비스 불가능!</p>
            </div>

            <img src="sync.gif" alt="동기 방식 데모" class="demo-gif">

            <p>위 GIF를 보면, 클라이언트가 <strong>하나씩 순차적으로</strong> 처리되는 것이 보입니다. Client 1이 끝나야 Client 2가 시작됩니다.</p>
        </section>

        <!-- 4. 해결책 - 비동기 -->
        <section class="section">
            <h2>4. 해결책 - 비동기(Asynchronous)</h2>

            <div class="question-box">
                <h4>질문</h4>
                <p>식당에 손님이 100명 왔는데 직원이 1명입니다. 한 손님 주문받고, 요리하고, 서빙하고... 그동안 99명은 대기... 이 식당이 손님을 빠르게 처리하려면 어떻게 해야 할까요?</p>
            </div>

            <div class="answer-box">
                <h4>답</h4>
                <p>일단 A 주문만 받고 요리하다가, 주문 오자마자 B 주문받아야지!</p>
            </div>

            <p>이게 바로 <strong>비동기(Asynchronous)</strong>의 핵심입니다!</p>

            <h3>해결책 1: 직원을 늘린다 (멀티스레드)</h3>

            <div class="diagram">손님 A → 직원 1이 전담
손님 B → 직원 2가 전담
손님 C → 직원 3이 전담</div>

            <div class="problem-box">
                <h4>멀티스레드의 문제</h4>
                <p>손님이 10,000명이면 직원도 10,000명 고용해야 할까요?</p>
                <p>스레드 1개 = 메모리 1MB 이상 소모 → 10,000개 = 10GB... 💀</p>
            </div>

            <h3>해결책 2: 한 명이 효율적으로 (비동기)</h3>

            <div class="diagram">직원 1명이:
  → A 주문 받음 (잠깐)
  → A 요리 시작해둠 (오븐에 넣어두고)
  → B 주문 받음 (잠깐)
  → B 요리 시작해둠
  → A 요리 완료! 서빙
  → C 주문 받음...</div>

            <p><strong>"기다리지 않고" 다른 일을 먼저 처리</strong>하는 방식!</p>

            <div class="question-box">
                <h4>질문</h4>
                <p>비동기 방식에서 <code>recv()</code>가 "바로 리턴"한다면... 데이터가 아직 안 왔는데 어떻게 알죠? 오븐에 요리 넣어뒀는데, 다 됐는지 안 됐는지 어떻게 확인하나요?</p>
            </div>

            <div class="answer-box">
                <h4>답</h4>
                <p>주기적으로 확인하거나 알림 받아야 하지 않나?</p>
            </div>

            <table>
                <tr>
                    <th>방식</th>
                    <th>설명</th>
                    <th>비유</th>
                </tr>
                <tr>
                    <td><strong>폴링 (Polling)</strong></td>
                    <td>계속 물어봄: "다 됐어?"</td>
                    <td>오븐 앞에서 계속 들여다보기</td>
                </tr>
                <tr>
                    <td><strong>이벤트 (Event)</strong></td>
                    <td>완료되면 알려줌</td>
                    <td>오븐 타이머가 "띵!" 울림</td>
                </tr>
            </table>

            <h3>Select 모델 (폴링 방식)</h3>

            <pre><code>while(1) {
    // 모든 소켓을 검사: "누구 데이터 왔어?"
    select(sockets, ...);

    for(각 소켓) {
        if(데이터 왔으면) {
            recv(socket, ...);  // 처리
        }
    }
}</code></pre>

            <div class="question-box">
                <h4>질문</h4>
                <p>손님 1,000명이 앉아있는데, 실제로 주문할 사람은 3명뿐입니다. 직원이 1,000개 테이블을 매번 다 돌아보는 게 효율적일까요?</p>
            </div>

            <div class="answer-box">
                <h4>답</h4>
                <p>비효율적이지, 쓸데없이 확인하느라 시간 낭비!</p>
            </div>

            <img src="select.gif" alt="Select 방식 데모" class="demo-gif">

            <p>Select 방식은 <strong>동시에 여러 클라이언트를 처리</strong>할 수 있지만, 소켓이 많아질수록 폴링 오버헤드가 증가합니다.</p>
        </section>

        <!-- 5. Overlapped I/O -->
        <section class="section">
            <h2>5. 한 단계 더 - Overlapped I/O</h2>

            <p>이벤트 방식이 폴링보다 낫긴 한데... 문제가 있습니다.</p>

            <div class="diagram">1. 소켓에서 "데이터 왔다!" 알림 받음
2. recv() 호출해서 데이터 읽음 ← 이때 잠깐 멈춤(블로킹)
3. 처리 완료</div>

            <p>알림을 받고 나서 <strong>실제로 데이터를 읽는 동안</strong>은 여전히 기다려야 해요.</p>

            <div class="question-box">
                <h4>질문</h4>
                <p>"알림 받는 것"뿐만 아니라, "데이터 읽는 작업 자체"도 기다리지 않게 할 수는 없을까요?</p>
                <p>힌트: 누군가한테 "이거 읽어서 여기 갖다 놔"라고 시켜놓고 나는 다른 일 하면?</p>
            </div>

            <div class="answer-box">
                <h4>답</h4>
                <p>오, 좋은데?</p>
            </div>

            <p>이게 바로 <strong>Overlapped I/O</strong>입니다!</p>

            <div class="insight-box">
                <h4>Overlapped I/O 핵심</h4>
                <p>"OS야, 이 소켓에서 데이터 읽어서 이 버퍼에 넣어놔. 다 되면 알려줘."</p>
                <p>→ 나는 바로 다른 일 하러 감!</p>
            </div>

            <pre><code>// Overlapped I/O 방식
OVERLAPPED overlapped = {0};

WSARecv(socket, buffer, ..., &overlapped);  // 작업 요청만 하고
// ↓ 바로 다음 줄 실행됨! (기다리지 않음)

// 나는 다른 일 하는 중...
// ...

// 나중에 완료 확인
GetOverlappedResult(...);  // "아까 그거 다 됐어?"</code></pre>

            <img src="overlapped.gif" alt="Overlapped I/O 방식 데모" class="demo-gif">

            <p>Overlapped I/O는 <strong>I/O 작업 자체를 OS에게 맡기고</strong> 바로 다른 일을 할 수 있습니다.</p>

            <table>
                <tr>
                    <th>단계</th>
                    <th>동기</th>
                    <th>Select</th>
                    <th>Overlapped</th>
                </tr>
                <tr>
                    <td>요청</td>
                    <td>직접 기다림</td>
                    <td>알림 받음</td>
                    <td>알림 받음</td>
                </tr>
                <tr>
                    <td>I/O 처리</td>
                    <td>직접 (기다림)</td>
                    <td>직접 (기다림)</td>
                    <td><strong>OS가 처리</strong></td>
                </tr>
                <tr>
                    <td>나는?</td>
                    <td>계속 기다림</td>
                    <td>중간중간 기다림</td>
                    <td><strong>계속 다른 일 가능</strong></td>
                </tr>
            </table>
        </section>

        <!-- 6. IOCP -->
        <section class="section">
            <h2>6. 최종 진화 - IOCP</h2>

            <p>Overlapped I/O 좋습니다. 근데 생각해보세요.</p>

            <div class="question-box">
                <h4>상황</h4>
                <p>클라이언트가 1,000명 접속 중입니다. 각각 읽기/쓰기 작업을 OS한테 시켜놨어요. 이제 완료 알림이 동시에 여러 개 옵니다.</p>
                <p>"A 읽기 완료!" "B 쓰기 완료!" "C 읽기 완료!" ... (수백 개가 동시에)</p>
                <p><strong>이 수많은 완료 알림들을 효율적으로 관리하려면 어떻게 해야 할까요?</strong></p>
            </div>

            <div class="answer-box">
                <h4>답</h4>
                <p>한 곳에 모아서 순서대로 처리?</p>
            </div>

            <p>정확합니다! 이게 바로 <strong>IOCP (I/O Completion Port)</strong>입니다!</p>

            <div class="insight-box">
                <h4>IOCP = 완료된 작업들이 모이는 큐</h4>
                <p>회사에서 여러 부서의 보고서가 마구 들어올 때, 중앙 수신함에 모아두고 직원들이 하나씩 꺼내서 처리하는 것과 같습니다.</p>
            </div>

            <div class="diagram">         완료 알림들
              ↓
    ┌─────────────────────┐
    │   Completion Port   │  ← 완료된 작업들이 여기 쌓임
    │   (대기열/큐)        │
    └─────────────────────┘
              ↓
     Worker Thread들이 꺼내서 처리</div>

            <pre><code>// 1. Completion Port 생성 (중앙 수신함 만들기)
HANDLE iocp = CreateIoCompletionPort(...);

// 2. 소켓들을 IOCP에 등록
CreateIoCompletionPort(socket, iocp, ...);

// 3. 작업 요청 (Overlapped I/O)
WSARecv(socket, buffer, ..., &overlapped);

// 4. Worker Thread에서 완료된 작업 꺼내기
while(1) {
    GetQueuedCompletionStatus(iocp, ...);  // 완료된 거 있으면 가져옴
    처리(overlapped);
}</code></pre>

            <img src="iocp.gif" alt="IOCP 방식 데모" class="demo-gif">

            <p>IOCP에서는 <strong>Worker Thread들이 Completion Queue에서 작업을 꺼내</strong> 동시에 처리합니다.</p>

            <div class="question-box">
                <h4>질문</h4>
                <p>왜 IOCP에서는 스레드를 적게 써도 될까요? 10,000명이 접속해도요?</p>
            </div>

            <div class="answer-box">
                <h4>답</h4>
                <p>실제로 동시에 보내는 건 일부뿐이니까!</p>
            </div>

            <p>정확합니다! <strong>접속 수 ≠ 동시 작업 수</strong></p>

            <div class="diagram">클라이언트 10,000명 접속
      ↓
실제로 동시에 뭔가 하는 사람: 100명 정도
      ↓
Worker Thread 8개로도 충분히 처리 가능!</div>

            <h3>Overlapped I/O vs IOCP 차이</h3>

            <div class="question-box">
                <h4>질문</h4>
                <p>Overlapped I/O랑 IOCP 차이가 뭔가요? 큐의 유무?</p>
            </div>

            <table>
                <tr>
                    <th></th>
                    <th>Overlapped I/O</th>
                    <th>IOCP</th>
                </tr>
                <tr>
                    <td>정체</td>
                    <td>비동기 작업 <strong>방식</strong></td>
                    <td>완료 알림 <strong>관리 시스템</strong></td>
                </tr>
                <tr>
                    <td>비유</td>
                    <td>알바한테 일 시키기</td>
                    <td>알바들 완료 보고를 <strong>한 곳에서</strong> 관리</td>
                </tr>
                <tr>
                    <td>관계</td>
                    <td>-</td>
                    <td>Overlapped I/O를 <strong>사용함</strong></td>
                </tr>
            </table>

            <p><code>IOCP = Overlapped I/O + 완료 큐 + 효율적인 스레드 관리</code></p>
        </section>

        <!-- 최종 요약 -->
        <section class="section">
            <h2>최종 정리</h2>

            <div class="summary-box">
                <h3>Socket I/O 모델 진화 과정</h3>
                <p><strong>1. 동기 (Sync)</strong> - 한 명씩 처리, 기다림 → 확장 불가</p>
                <p><strong>2. 비동기 (Select)</strong> - 기다리지 않고 나중에 확인 → 폴링 오버헤드</p>
                <p><strong>3. Overlapped I/O</strong> - I/O 작업 자체를 OS에게 맡김 → 완료 관리 복잡</p>
                <p><strong>4. IOCP</strong> - 완료 알림을 큐로 모아서 효율적으로 처리 → Windows 최고 성능!</p>
            </div>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>특성</th>
                        <th>동기</th>
                        <th>Select</th>
                        <th>Overlapped</th>
                        <th>IOCP</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>동시 처리</td>
                        <td>1명</td>
                        <td>수백 명</td>
                        <td>수천 명</td>
                        <td><strong>수만 명+</strong></td>
                    </tr>
                    <tr>
                        <td>구현 난이도</td>
                        <td>쉬움</td>
                        <td>보통</td>
                        <td>어려움</td>
                        <td>어려움</td>
                    </tr>
                    <tr>
                        <td>CPU 효율</td>
                        <td>낮음</td>
                        <td>보통</td>
                        <td>높음</td>
                        <td><strong>최상</strong></td>
                    </tr>
                    <tr>
                        <td>적합한 용도</td>
                        <td>테스트</td>
                        <td>소규모</td>
                        <td>중규모</td>
                        <td><strong>대규모 게임서버</strong></td>
                    </tr>
                </tbody>
            </table>
        </section>

        <footer class="footer">
            <p>MSH Portfolio - Game Server Developer</p>
        </footer>
    </div>
</body>
</html>
