<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DB Connection Pool 성능 테스트 - MSH Portfolio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.8;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 60px 20px;
        }

        .nav {
            margin-bottom: 40px;
        }

        .nav a {
            color: #666;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .nav a:hover {
            color: #333;
        }

        .header {
            margin-bottom: 50px;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 16px;
            color: #111;
        }

        .header-meta {
            display: flex;
            gap: 20px;
            color: #666;
            font-size: 0.9rem;
        }

        .section {
            margin-bottom: 50px;
        }

        .section h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #111;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .section h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 30px 0 15px 0;
            color: #333;
        }

        .section p {
            margin-bottom: 16px;
            color: #444;
        }

        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }

        pre code {
            background: none;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }

        th, td {
            padding: 14px 16px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background: #f8f8f8;
            font-weight: 600;
            color: #333;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .result-box {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
        }

        .result-box h3 {
            color: white;
            margin-top: 0;
            font-size: 1.3rem;
        }

        .result-box .big-number {
            font-size: 3rem;
            font-weight: 700;
            margin: 10px 0;
        }

        .insight-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin: 20px 0;
        }

        .insight-box h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .insight-box.blue {
            background: #e3f2fd;
            border-left-color: #2196f3;
        }

        .insight-box.blue h4 {
            color: #1565c0;
        }

        .insight-box.green {
            background: #e8f5e9;
            border-left-color: #4caf50;
        }

        .insight-box.green h4 {
            color: #2e7d32;
        }

        ul, ol {
            margin: 16px 0;
            padding-left: 24px;
        }

        li {
            margin-bottom: 8px;
        }

        .diagram {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 24px;
            margin: 20px 0;
            font-family: 'Consolas', monospace;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.4;
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 20px 0;
        }

        .tag {
            background: #e8f4fd;
            color: #1976d2;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .footer {
            text-align: center;
            padding: 40px 0;
            color: #999;
            font-size: 0.9rem;
            border-top: 1px solid #e0e0e0;
            margin-top: 60px;
        }

        .compare-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        @media (max-width: 600px) {
            .compare-grid {
                grid-template-columns: 1fr;
            }
        }

        .compare-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            border: 1px solid #eee;
        }

        .compare-card h4 {
            font-size: 1.1rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .compare-card.slow h4 {
            color: #d32f2f;
        }

        .compare-card.fast h4 {
            color: #388e3c;
        }

        .test-scenario {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 24px;
            margin: 20px 0;
        }

        .test-scenario h4 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        /* 토글 섹션 스타일 */
        .toggle-section {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin: 16px 0;
            overflow: hidden;
        }

        .toggle-section summary {
            padding: 16px 20px;
            cursor: pointer;
            font-weight: 600;
            color: #1976d2;
            background: #f8f9fa;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-section summary::-webkit-details-marker {
            display: none;
        }

        .toggle-section summary::before {
            content: '+';
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            background: #1976d2;
            color: white;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
        }

        .toggle-section[open] summary::before {
            content: '-';
        }

        .toggle-section summary:hover {
            background: #e3f2fd;
        }

        .toggle-content {
            padding: 20px;
            border-top: 1px solid #e0e0e0;
        }

        .toggle-content h4 {
            color: #333;
            margin: 20px 0 12px 0;
            font-size: 1.05rem;
        }

        .toggle-content h4:first-child {
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav">
            <a href="../../">&larr; 돌아가기</a>
        </nav>

        <header class="header">
            <h1>DB Connection Pool 성능 테스트</h1>
            <div class="header-meta">
                <span>C++ / Windows</span>
                <span>Docker MSSQL</span>
            </div>
            <div class="tags">
                <span class="tag">Connection Pool</span>
                <span class="tag">MSSQL</span>
                <span class="tag">ODBC</span>
                <span class="tag">성능 테스트</span>
                <span class="tag">게임 서버</span>
            </div>
        </header>

        <!-- 개요 -->
        <section class="section">
            <h2>개요</h2>
            <p>
                데이터베이스 연결(Connection)은 생각보다 비용이 큰 작업입니다.
                TCP 핸드셰이크, 인증, 세션 생성 등 여러 단계를 거치기 때문입니다.
            </p>
            <p>
                <strong>Connection Pool</strong>은 미리 연결을 만들어두고 재사용하는 기법입니다.
                이 테스트에서는 Pool 사용 여부에 따른 성능 차이를 직접 측정해보았습니다.
            </p>
        </section>

        <!-- Connection 비용 분석 -->
        <section class="section">
            <h2>Connection 비용 분석</h2>

            <h3>Connect() 한 번에 일어나는 일</h3>
            <div class="diagram">[클라이언트]                    [DB 서버]
    |                              |
    |--- SYN ------------------->  |  (1) TCP 연결 시작
    |                              |
    |<-- SYN-ACK ----------------  |  (2) 응답
    |                              |
    |--- ACK ------------------->  |  (3) 연결 수립
    |                              |
    |--- 인증 요청 ------------->  |  (4) ID/PW 전송
    |                              |
    |<-- 인증 확인 --------------  |  (5) 세션 생성
    |                              |
    |--- 쿼리 실행 ------------->  |  ★ 실제 작업
    |                              |
    |<-- 결과 반환 --------------  |
    |                              |
    |--- FIN ------------------->  |  (6) 종료 시작
    |                              |
    |<-- FIN-ACK ---------------  |  (7) 종료 완료</div>

            <div class="insight-box blue">
                <h4>핵심 포인트</h4>
                <p>
                    쿼리 자체는 1ms도 안 걸릴 수 있지만, Connect/Close 오버헤드가
                    <strong>수십 ms</strong>가 될 수 있습니다.
                    매 요청마다 이 과정을 반복하면 엄청난 낭비입니다.
                </p>
            </div>
        </section>

        <!-- Connection Pool이란 -->
        <section class="section">
            <h2>Connection Pool이란?</h2>

            <div class="compare-grid">
                <div class="compare-card slow">
                    <h4>Pool 없이</h4>
                    <div class="diagram" style="font-size: 0.8rem; padding: 12px;">요청1 → Connect → 쿼리 → Close
요청2 → Connect → 쿼리 → Close
요청3 → Connect → 쿼리 → Close
        ↑
   매번 오버헤드 발생!</div>
                </div>
                <div class="compare-card fast">
                    <h4>Pool 사용</h4>
                    <div class="diagram" style="font-size: 0.8rem; padding: 12px;">[미리 연결 만들어둠]
        ↓
요청1 → 빌려씀 → 쿼리 → 반납
요청2 → 빌려씀 → 쿼리 → 반납
요청3 → 빌려씀 → 쿼리 → 반납
        ↑
   Connect/Close 없음!</div>
                </div>
            </div>

            <h3>Pool 내부 구조</h3>
            <div class="diagram">┌─────────────────────────────────────┐
│            Pool Manager             │
├─────────────────────────────────────┤
│  [연결1: 사용중]                      │
│  [연결2: 대기중] ←── 요청 오면 빌려줌   │
│  [연결3: 대기중]                      │
│  [연결4: 사용중]                      │
│  [연결5: 대기중]                      │
└─────────────────────────────────────┘</div>
        </section>

        <!-- 테스트 환경 -->
        <section class="section">
            <h2>테스트 환경</h2>

            <table>
                <tr>
                    <th>항목</th>
                    <th>상세</th>
                </tr>
                <tr>
                    <td>OS</td>
                    <td>Windows (Docker Desktop)</td>
                </tr>
                <tr>
                    <td>MSSQL</td>
                    <td>Docker Container (localhost:1433)</td>
                </tr>
                <tr>
                    <td>언어</td>
                    <td>C++ (Visual Studio 2022)</td>
                </tr>
                <tr>
                    <td>DB 연결</td>
                    <td>ODBC (SQL Server Driver 17)</td>
                </tr>
                <tr>
                    <td>쿼리 횟수</td>
                    <td>1,000회</td>
                </tr>
            </table>
        </section>

        <!-- 테스트 설계 -->
        <section class="section">
            <h2>테스트 설계</h2>

            <div class="test-scenario">
                <h4>싱글 스레드 환경 테스트</h4>
                <table>
                    <tr>
                        <th></th>
                        <th>Test A (No Pool)</th>
                        <th>Test B (Connection Reuse)</th>
                    </tr>
                    <tr>
                        <td>방식</td>
                        <td>매 쿼리마다 Connect/Close</td>
                        <td>한 번 Connect, 1000번 쿼리, Close</td>
                    </tr>
                    <tr>
                        <td>Connect 횟수</td>
                        <td>1,000번</td>
                        <td>1번</td>
                    </tr>
                    <tr>
                        <td>쿼리 횟수</td>
                        <td>1,000번</td>
                        <td>1,000번</td>
                    </tr>
                </table>
            </div>

            <h3>테스트 코드 핵심</h3>
<pre><code>// Test A: 매번 Connect/Close
for (int i = 0; i < 1000; i++) {
    Connect();      // 매번 연결
    ExecuteQuery(); // 쿼리 실행
    Close();        // 매번 종료
}

// Test B: 연결 유지 (Pool 효과)
Connect();          // 한 번만 연결
for (int i = 0; i < 1000; i++) {
    ExecuteQuery(); // 쿼리만 실행
}
Close();            // 한 번만 종료</code></pre>
        </section>

        <!-- 테스트 결과 -->
        <section class="section">
            <h2>테스트 결과</h2>

            <div class="result-box">
                <h3>싱글 스레드 테스트 결과 (1000회 쿼리)</h3>
                <table style="background: rgba(255,255,255,0.1); color: white;">
                    <tr>
                        <th style="background: rgba(255,255,255,0.1); color: white;">방식</th>
                        <th style="background: rgba(255,255,255,0.1); color: white;">총 시간</th>
                        <th style="background: rgba(255,255,255,0.1); color: white;">쿼리당 평균</th>
                    </tr>
                    <tr>
                        <td style="color: white;">Test A (No Pool)</td>
                        <td style="color: white;">34,312ms</td>
                        <td style="color: white;">34.3ms</td>
                    </tr>
                    <tr>
                        <td style="color: white;">Test B (Connection Reuse)</td>
                        <td style="color: white;">419ms</td>
                        <td style="color: white;">0.42ms</td>
                    </tr>
                </table>
                <div class="big-number">82배 빠름!</div>
                <p style="font-size: 0.9rem; opacity: 0.9; margin-top: 10px;">
                    Connect/Close 오버헤드: 약 34ms/쿼리
                </p>
            </div>

            <div class="insight-box">
                <h4>왜 34ms나 걸리나?</h4>
                <p>
                    이론적으로 TCP handshake + 인증은 5ms 정도지만, 실제로는:
                </p>
                <ul>
                    <li>Docker 네트워크 레이어 (호스트 → 컨테이너)</li>
                    <li>ODBC 드라이버 초기화</li>
                    <li>SQL Server 세션 메모리 할당</li>
                    <li>Windows 소켓 생성/해제</li>
                </ul>
                <p>
                    이 모든 것이 합쳐져서 34ms가 됩니다.
                </p>
            </div>
        </section>

        <!-- 실제 게임 서버와의 연결 -->
        <section class="section">
            <h2>실제 게임 서버에서의 적용</h2>

            <h3>현재 게임 서버 구조 (싱글스레드)</h3>
            <div class="diagram">┌─────────────────────────────────────────────┐
│              게임 서버                       │
├─────────────────────────────────────────────┤
│  CDBConnection m_OLEDBConnection;           │
│                                             │
│  // 서버 시작 시 1번 Connect()              │
│  // 메시지 처리 루프에서 쿼리만 실행         │
│  // 서버 종료 시 Close()                    │
│                                             │
│  → Connection Pool과 동일한 효과!           │
└─────────────────────────────────────────────┘</div>

            <div class="insight-box green">
                <h4>핵심 교훈</h4>
                <p>
                    <strong>싱글스레드 서버</strong>에서는 연결 1개를 유지하는 것만으로도 충분합니다.
                    매번 Connect/Close 하지 않고 연결을 재사용하는 것이 핵심입니다.
                </p>
                <p style="margin-top: 12px;">
                    <strong>멀티스레드 서버</strong>에서는 여러 스레드가 동시에 쿼리를 실행하므로,
                    Connection Pool에서 여러 연결을 관리하고 빌려주는 방식이 필요합니다.
                </p>
            </div>
        </section>

        <!-- Pool 설계 시 고려사항 -->
        <section class="section">
            <h2>Connection Pool 설계 시 고려사항</h2>

            <h3>Pool 크기 설정</h3>
            <div class="diagram">권장 Pool Size = (CPU 코어 수 x 2) + 디스크 수

예: 4코어 DB 서버, SSD 1개
→ (4 x 2) + 1 = 9~10개</div>

            <details class="toggle-section">
                <summary>왜 코어 x 2인가? (클릭해서 자세히 보기)</summary>
                <div class="toggle-content">
                    <h4>식당 비유로 이해하기</h4>
                    <div class="diagram">주방장 4명 (= CPU 코어 4개)
손님 주문 = DB 쿼리

주문 처리 과정:
1. 요리 준비 (CPU 작업) = 1분
2. 오븐에서 굽기 (I/O 대기) = 9분  ← 주방장이 기다리기만 함</div>

                    <h4>시나리오 1: 테이블 4개 (연결 4개)</h4>
                    <div class="diagram">주방장A → 테이블1 주문받음 → 1분 요리 → 오븐에 넣음 → 9분 대기...
주방장B → 테이블2 주문받음 → 1분 요리 → 오븐에 넣음 → 9분 대기...
주방장C → 테이블3 주문받음 → 1분 요리 → 오븐에 넣음 → 9분 대기...
주방장D → 테이블4 주문받음 → 1분 요리 → 오븐에 넣음 → 9분 대기...

문제: 4명의 주방장이 9분 동안 손 놓고 오븐만 쳐다봄!
결과: 10분에 4개 주문 처리</div>

                    <h4>시나리오 2: 테이블 8개 (연결 8개 = 코어 x 2)</h4>
                    <div class="diagram">주방장A → 테이블1 요리(1분) → 오븐에 넣음 → 바로 테이블5 요리 시작!
주방장B → 테이블2 요리(1분) → 오븐에 넣음 → 바로 테이블6 요리 시작!
주방장C → 테이블3 요리(1분) → 오븐에 넣음 → 바로 테이블7 요리 시작!
주방장D → 테이블4 요리(1분) → 오븐에 넣음 → 바로 테이블8 요리 시작!

핵심: 오븐이 굽는 동안 주방장은 다른 테이블 요리함!
결과: 10분에 8개 주문 처리 (2배!)</div>

                    <div class="insight-box blue">
                        <h4>왜 x2가 적당한가?</h4>
                        <p>
                            CPU 작업 : I/O 대기 = 약 1 : 9 비율 (DB 쿼리 특성)
                        </p>
                        <p>
                            → 주방장 1명이 오븐 기다리는 동안 다른 주문 1개 더 처리 가능<br>
                            → 그래서 테이블(연결)이 2배 필요<br>
                            → <strong>코어 4개 x 2 = 연결 8개</strong>
                        </p>
                    </div>
                </div>
            </details>

            <details class="toggle-section">
                <summary>디스크 수는 왜 더하나? (클릭해서 자세히 보기)</summary>
                <div class="toggle-content">
                    <h4>오븐 개수 = 디스크 개수</h4>
                    <div class="diagram">오븐 1개 → 동시에 1개만 구워짐
오븐 2개 → 동시에 2개 구워짐 → 테이블 2개 더 받아도 됨!

(코어 x 2) + 오븐 수 = Pool Size
(4 x 2) + 2 = 10개</div>

                    <div class="insight-box">
                        <h4>실제 상황</h4>
                        <ul>
                            <li><strong>디스크 1개:</strong> 동시에 1개 I/O만 처리</li>
                            <li><strong>디스크 2개:</strong> 동시에 2개 I/O 처리 가능</li>
                            <li><strong>RAID/SSD 여러개:</strong> 병렬 I/O로 처리량 증가</li>
                        </ul>
                        <p style="margin-top: 12px;">
                            디스크가 많으면 병렬 I/O가 가능하므로, 그만큼 연결을 더 늘려도 병목이 안 생깁니다.
                        </p>
                    </div>
                </div>
            </details>

            <h3>Pool이 가득 찼을 때 전략</h3>
            <table>
                <tr>
                    <th>전략</th>
                    <th>동작</th>
                    <th>장단점</th>
                </tr>
                <tr>
                    <td>대기 (Wait)</td>
                    <td>연결 반납될 때까지 대기</td>
                    <td>DB 과부하 방지 / 대기 시간 발생</td>
                </tr>
                <tr>
                    <td>확장 (Grow)</td>
                    <td>새 연결 추가 생성</td>
                    <td>대기 없음 / DB 연결 폭주 가능</td>
                </tr>
                <tr>
                    <td>거부 (Reject)</td>
                    <td>에러 반환</td>
                    <td>빠른 실패 / 요청 실패</td>
                </tr>
            </table>
        </section>

        <!-- 결론 -->
        <section class="section">
            <h2>결론</h2>

            <table>
                <tr>
                    <th>방식</th>
                    <th>시간</th>
                    <th>차이</th>
                </tr>
                <tr>
                    <td>매번 Connect/Close</td>
                    <td>34,312ms</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>연결 유지 (Pool)</td>
                    <td>419ms</td>
                    <td><strong>82배 빠름</strong></td>
                </tr>
            </table>

            <div class="insight-box">
                <h4>핵심 교훈</h4>
                <ul>
                    <li>DB 연결은 <strong>비용이 큰 작업</strong>입니다 (TCP, 인증, 세션 생성)</li>
                    <li>연결을 <strong>재사용</strong>하면 82배 성능 향상이 가능합니다</li>
                    <li>싱글스레드: 연결 1개 유지로 충분</li>
                    <li>멀티스레드: Connection Pool로 여러 연결 관리</li>
                    <li>Pool 크기는 (코어 x 2) + 디스크 수가 적절</li>
                </ul>
            </div>
        </section>

        <footer class="footer">
            <p>MSH Portfolio - Game Server Developer</p>
        </footer>
    </div>
</body>
</html>
