<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++11 Modern Features - MSH Portfolio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.8;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 60px 20px;
        }

        .nav {
            margin-bottom: 40px;
        }

        .nav a {
            color: #666;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .nav a:hover {
            color: #333;
        }

        .header {
            margin-bottom: 50px;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 16px;
            color: #111;
        }

        .header-meta {
            display: flex;
            gap: 20px;
            color: #666;
            font-size: 0.9rem;
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 20px 0;
        }

        .tag {
            background: #e8f4fd;
            color: #1976d2;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .section {
            margin-bottom: 50px;
        }

        .section h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #111;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .section h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 30px 0 15px 0;
            color: #333;
        }

        .section p {
            margin-bottom: 16px;
            color: #444;
        }

        /* 대화형 질문-답변 스타일 */
        .question-box {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            border-left: 4px solid #667eea;
            padding: 20px;
            border-radius: 0 12px 12px 0;
            margin: 25px 0;
        }

        .question-box .q-label {
            color: #667eea;
            font-weight: 700;
            font-size: 0.85rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .question-box .q-label::before {
            content: "Q";
            background: #667eea;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .question-box .question {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
        }

        .thinking-box {
            background: #fff8e1;
            border-left: 4px solid #ffb300;
            padding: 20px;
            border-radius: 0 12px 12px 0;
            margin: 20px 0;
        }

        .thinking-box .t-label {
            color: #f57c00;
            font-weight: 700;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .answer-box {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 20px;
            border-radius: 0 12px 12px 0;
            margin: 20px 0;
        }

        .answer-box .a-label {
            color: #2e7d32;
            font-weight: 700;
            font-size: 0.85rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .answer-box .a-label::before {
            content: "A";
            background: #4caf50;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .insight-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin: 20px 0;
        }

        .insight-box h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .insight-box.blue {
            background: #e3f2fd;
            border-left-color: #2196f3;
        }

        .insight-box.blue h4 {
            color: #1565c0;
        }

        .insight-box.green {
            background: #e8f5e9;
            border-left-color: #4caf50;
        }

        .insight-box.green h4 {
            color: #2e7d32;
        }

        .insight-box.red {
            background: #ffebee;
            border-left-color: #f44336;
        }

        .insight-box.red h4 {
            color: #c62828;
        }

        ul, ol {
            margin: 16px 0;
            padding-left: 24px;
        }

        li {
            margin-bottom: 8px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }

        th, td {
            padding: 14px 16px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background: #f8f8f8;
            font-weight: 600;
            color: #333;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .footer {
            text-align: center;
            padding: 40px 0;
            color: #999;
            font-size: 0.9rem;
            border-top: 1px solid #e0e0e0;
            margin-top: 60px;
        }

        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }

        pre code {
            background: none;
            padding: 0;
        }

        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            font-weight: 700;
            font-size: 0.9rem;
            margin-right: 10px;
        }

        .compare-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        @media (max-width: 600px) {
            .compare-grid {
                grid-template-columns: 1fr;
            }
        }

        .compare-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            border: 1px solid #eee;
        }

        .compare-card h4 {
            font-size: 1rem;
            margin-bottom: 12px;
            color: #333;
        }

        .compare-card.old {
            border-top: 3px solid #f44336;
        }

        .compare-card.new {
            border-top: 3px solid #4caf50;
        }

        .diagram {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 24px;
            margin: 20px 0;
            font-family: 'Consolas', monospace;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.4;
            font-size: 0.85rem;
        }

        /* 토글 섹션 */
        .toggle-section {
            margin: 16px 0;
        }

        .toggle-section summary {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            cursor: pointer;
            font-weight: 500;
            color: #1e40af;
            background: #dbeafe;
            border-radius: 25px;
            list-style: none;
            transition: all 0.2s;
        }

        .toggle-section summary::-webkit-details-marker {
            display: none;
        }

        .toggle-section summary:hover {
            background: #bfdbfe;
            transform: translateY(-2px);
        }

        .toggle-content {
            margin-top: 12px;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            border: 1px solid #e5e7eb;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav">
            <a href="./">&larr; 목록</a>
            <a href="./cpp11.html" style="color: #667eea; font-weight: 600;">C++11</a>
            <a href="./cpp14.html">C++14</a>
            <a href="./cpp17.html">C++17</a>
            <a href="./cpp20.html">C++20</a>
            <a href="./rust.html" style="color: #f74c00;">Rust</a>
        </nav>

        <header class="header">
            <h1>C++11 Modern Features</h1>
            <div class="header-meta">
                <span>Modern C++</span>
                <span>Language Features</span>
            </div>
            <div class="tags">
                <span class="tag">C++11</span>
                <span class="tag">auto</span>
                <span class="tag">lambda</span>
                <span class="tag">smart pointer</span>
                <span class="tag">move semantics</span>
            </div>
        </header>

        <!-- 개요 -->
        <section class="section">
            <h2>개요</h2>
            <p>
                C++11은 "Modern C++"의 시작점입니다. 정말 많은 기능이 추가되었는데,
                <strong>실무에서 자주 쓰이는 것</strong>부터 질문-답변 형식으로 학습합니다.
            </p>
        </section>

        <!-- 1. auto -->
        <section class="section">
            <h2><span class="step-number">1</span>auto - 타입 추론</h2>

            <div class="question-box">
                <div class="q-label">질문</div>
                <div class="question">
                    아래 C++03 코드의 불편한 점은?
                </div>
            </div>

<pre><code>std::vector&lt;std::map&lt;std::string, int&gt;&gt; data;

// 순회하려면...
for (std::vector&lt;std::map&lt;std::string, int&gt;&gt;::iterator it = data.begin();
     it != data.end(); ++it) {
    // ...
}</code></pre>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p><strong>너무 길다!</strong></p>
                <p>컴파일러가 이미 <code>data</code>의 타입을 알고 있는데, 왜 <code>it</code>의 타입을 또 적어야 하지?</p>
            </div>

            <div class="answer-box">
                <div class="a-label">C++11 해결책: auto</div>
            </div>

            <div class="compare-grid">
                <div class="compare-card old">
                    <h4>C++03</h4>
<pre style="margin: 0; font-size: 0.8rem;"><code>std::vector&lt;...&gt;::iterator it = data.begin();</code></pre>
                </div>
                <div class="compare-card new">
                    <h4>C++11</h4>
<pre style="margin: 0; font-size: 0.8rem;"><code>auto it = data.begin();</code></pre>
                </div>
            </div>

            <div class="question-box">
                <div class="q-label">추가 질문</div>
                <div class="question">
                    auto를 남용하면 어떤 문제가 생길까?
                </div>
            </div>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p><strong>자료형을 모르겠다!</strong></p>
<pre style="margin: 10px 0;"><code>auto result = getSomething();  // 뭐가 반환되는지 모름</code></pre>
            </div>

            <div class="insight-box green">
                <h4>auto 사용 가이드</h4>
<pre><code>// 좋은 경우: 타입이 길거나 이미 명확할 때
auto it = container.begin();           // iterator 길어서
auto ptr = std::make_unique&lt;Player&gt;(); // 우측에 타입 있음

// 피해야 할 경우: 타입이 불명확할 때
auto config = getConfig();  // 뭔지 모름
int config = getConfig();   // 명확</code></pre>
            </div>
        </section>

        <!-- 2. Range-based for -->
        <section class="section">
            <h2><span class="step-number">2</span>Range-based for</h2>

            <div class="question-box">
                <div class="q-label">질문</div>
                <div class="question">
                    auto로 줄였지만 여전히 긴데, 더 간단하게 할 수 없을까?
                </div>
            </div>

<pre><code>for (auto it = nums.begin(); it != nums.end(); ++it) {
    std::cout << *it << std::endl;
}</code></pre>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p>그냥 컨테이너 전체를 순회하고 싶을 뿐인데...</p>
            </div>

            <div class="answer-box">
                <div class="a-label">Range-based for!</div>
<pre><code>// C++11 range-based for
for (int num : nums) {
    std::cout << num << std::endl;
}

// auto와 조합
for (auto& num : nums) {
    num *= 2;  // 참조라 수정 가능
}</code></pre>
            </div>

            <div class="question-box">
                <div class="q-label">추가 질문</div>
                <div class="question">
                    큰 객체를 순회할 때 그냥 <code>auto</code>로 받으면 어떤 문제가?
                </div>
            </div>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p><strong>복사된다!</strong> 복사 비용도 문제고, 원본이 바뀌지 않는다.</p>
            </div>

            <div class="insight-box">
                <h4>참조 규칙</h4>
<pre><code>for (auto item : items)        // 매번 복사 (느림)
for (const auto& item : items) // 참조, 읽기 전용 (빠름)
for (auto& item : items)       // 참조, 수정 가능 (빠름)</code></pre>
                <p style="margin-top: 12px;"><strong>규칙:</strong> 읽기만 하면 <code>const auto&</code>, 수정하면 <code>auto&</code></p>
            </div>
        </section>

        <!-- 3. nullptr -->
        <section class="section">
            <h2><span class="step-number">3</span>nullptr</h2>

            <div class="question-box">
                <div class="q-label">질문</div>
                <div class="question">
                    아래 코드에서 어떤 함수가 호출될까?
                </div>
            </div>

<pre><code>void func(int n);
void func(int* p);

func(NULL);  // ???</code></pre>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p><code>NULL</code>이 사실 <code>0</code>으로 정의되어 있다면...</p>
                <p><strong><code>func(int)</code>가 호출된다!</strong> 의도와 다름.</p>
            </div>

            <div class="answer-box">
                <div class="a-label">C++11 해결책: nullptr</div>
<pre><code>int* ptr = nullptr;

func(nullptr);  // func(int*) 호출 보장</code></pre>
                <p><code>nullptr</code>은 포인터 타입에만 변환됩니다.</p>
            </div>
        </section>

        <!-- 4. Lambda -->
        <section class="section">
            <h2><span class="step-number">4</span>람다 (Lambda)</h2>

            <div class="question-box">
                <div class="q-label">질문</div>
                <div class="question">
                    정렬할 때 비교 함수를 따로 만들어야 하나?
                </div>
            </div>

<pre><code>// C++03: 함수를 따로 정의해야 함
bool compareByScore(const Player& a, const Player& b) {
    return a.score > b.score;
}

std::sort(players.begin(), players.end(), compareByScore);</code></pre>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p>한 줄짜리 비교 로직인데 함수를 따로 만들어야 하나?</p>
                <p>기존엔 함수 객체도 클래스로 정의해야 했는데...</p>
                <p><strong>람다를 쓰면 컴파일러가 자동으로 임시 객체를 만들어준다!</strong></p>
            </div>

            <div class="answer-box">
                <div class="a-label">람다로 바로 정의!</div>
<pre><code>// C++11: 그 자리에서 바로
std::sort(players.begin(), players.end(),
    [](const Player& a, const Player& b) {
        return a.score > b.score;
    });</code></pre>
            </div>

            <details class="toggle-section">
                <summary>람다가 내부적으로 어떻게 동작하는지 보기</summary>
                <div class="toggle-content">
<pre><code>// 람다
auto cmp = [](const Player& a, const Player& b) {
    return a.score > b.score;
};

// 컴파일러가 내부적으로 이렇게 만듦
class __Lambda_123 {
public:
    bool operator()(const Player& a, const Player& b) const {
        return a.score > b.score;
    }
};</code></pre>
                </div>
            </details>

            <div class="question-box">
                <div class="q-label">추가 질문</div>
                <div class="question">
                    람다 안에서 외부 변수를 쓰고 싶으면?
                </div>
            </div>

<pre><code>int minScore = 100;

auto filter = [](const Player& p) {
    return p.score > minScore;  // 에러! minScore를 모름
};</code></pre>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p><strong>캡처 리스트!</strong> <code>[=]</code> 아니면 <code>[&]</code></p>
            </div>

            <div class="answer-box">
                <div class="a-label">캡처 리스트 사용</div>
<pre><code>[=]  // 값으로 캡처 (복사)
[&]  // 참조로 캡처

[=](const Player& p) { return p.score > minScore; }  // minScore 복사됨
[&](const Player& p) { return p.score > minScore; }  // minScore 참조

// 개별 지정도 가능
[minScore]        // minScore만 값 캡처
[&minScore]       // minScore만 참조 캡처
[=, &minScore]    // 기본 값, minScore만 참조</code></pre>
            </div>
        </section>

        <!-- 5. Smart Pointers -->
        <section class="section">
            <h2><span class="step-number">5</span>스마트 포인터</h2>

            <div class="question-box">
                <div class="q-label">질문</div>
                <div class="question">
                    delete를 깜빡하면 메모리 누수! 자동으로 해주면 안 될까?
                </div>
            </div>

<pre><code>void process() {
    Player* p = new Player();

    if (someCondition) {
        return;  // delete 안 하고 빠져나감! 누수!
    }

    delete p;
}</code></pre>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p><strong>unique_ptr, shared_ptr!</strong></p>
            </div>

            <div class="answer-box">
                <div class="a-label">스마트 포인터 사용</div>
<pre><code>// unique_ptr: 단독 소유
std::unique_ptr&lt;Player&gt; p1 = std::make_unique&lt;Player&gt;();  // C++14
// 스코프 벗어나면 자동 delete

// shared_ptr: 공유 소유
std::shared_ptr&lt;Player&gt; p2 = std::make_shared&lt;Player&gt;();
std::shared_ptr&lt;Player&gt; p3 = p2;  // 참조 카운트 2
// 마지막 shared_ptr 소멸 시 delete</code></pre>
            </div>

            <div class="question-box">
                <div class="q-label">추가 질문</div>
                <div class="question">
                    unique_ptr은 복사가 안 되는데, 함수에 넘기려면?
                </div>
            </div>

<pre><code>std::unique_ptr&lt;Player&gt; p1 = std::make_unique&lt;Player&gt;();
std::unique_ptr&lt;Player&gt; p2 = p1;  // 에러! 복사 불가</code></pre>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p><strong>move!</strong> 소유권을 이동한다.</p>
            </div>

            <div class="answer-box">
                <div class="a-label">std::move로 소유권 이동</div>
<pre><code>std::unique_ptr&lt;Player&gt; player = std::make_unique&lt;Player&gt;();
process(std::move(player));  // 소유권 이동

// 이 시점에서 player는 nullptr</code></pre>
            </div>
        </section>

        <!-- 6. Move Semantics -->
        <section class="section">
            <h2><span class="step-number">6</span>Move Semantics</h2>

            <div class="question-box">
                <div class="q-label">질문</div>
                <div class="question">
                    vector를 다른 변수에 할당하면 전체가 복사되는데, 더 효율적인 방법은?
                </div>
            </div>

<pre><code>std::vector&lt;int&gt; v1 = {1, 2, 3, 4, 5};
std::vector&lt;int&gt; v2 = v1;  // 복사: 모든 원소 복사됨</code></pre>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p>만약 <code>v1</code>을 더 이상 안 쓸 거라면?</p>
                <p><strong>포인터만 옮기면</strong> 되지 않나?</p>
            </div>

            <div class="answer-box">
                <div class="a-label">std::move로 이동</div>
<pre><code>std::vector&lt;int&gt; v1 = {1, 2, 3, 4, 5};
std::vector&lt;int&gt; v2 = std::move(v1);  // 이동: 포인터만 옮김
// v1은 이제 비어있음</code></pre>
            </div>

            <div class="diagram">[복사]
v1: [1,2,3,4,5]  →  v1: [1,2,3,4,5]
                    v2: [1,2,3,4,5]  (새로 할당)

[이동]
v1: [1,2,3,4,5]  →  v1: []
                    v2: [1,2,3,4,5]  (포인터만 이동)</div>

            <div class="question-box">
                <div class="q-label">추가 질문</div>
                <div class="question">
                    std::move는 언제 쓰면 좋고, 언제 위험할까?
                </div>
            </div>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p><strong>원본을 더 이상 안 써야 할 때</strong> 쓰면 좋고,</p>
                <p><strong>같이 써야 하면 위험</strong>하다!</p>
            </div>

            <div class="insight-box red">
                <h4>주의!</h4>
<pre><code>// 위험한 사용
std::vector&lt;int&gt; v1 = {1, 2, 3};
std::vector&lt;int&gt; v2 = std::move(v1);
v1.push_back(4);  // 위험! v1은 유효하지 않은 상태</code></pre>
            </div>
        </section>

        <!-- 핵심 정리 -->
        <section class="section">
            <h2>C++11 핵심 정리</h2>

            <div class="insight-box">
                <h4>가장 많이 쓰는 기능들</h4>
                <table>
                    <tr>
                        <th>기능</th>
                        <th>핵심</th>
                        <th>사용 시점</th>
                    </tr>
                    <tr>
                        <td><code>auto</code></td>
                        <td>타입 추론</td>
                        <td>긴 타입, iterator</td>
                    </tr>
                    <tr>
                        <td>range-based for</td>
                        <td><code>for (auto& x : c)</code></td>
                        <td>컨테이너 전체 순회</td>
                    </tr>
                    <tr>
                        <td><code>nullptr</code></td>
                        <td>타입 안전한 널</td>
                        <td>항상 (NULL 대신)</td>
                    </tr>
                    <tr>
                        <td>람다</td>
                        <td><code>[캡처](매개) { }</code></td>
                        <td>콜백, 정렬 비교</td>
                    </tr>
                    <tr>
                        <td><code>unique_ptr</code></td>
                        <td>단독 소유, 자동 해제</td>
                        <td>단일 소유권</td>
                    </tr>
                    <tr>
                        <td><code>shared_ptr</code></td>
                        <td>공유 소유, 참조 카운트</td>
                        <td>공유 소유권</td>
                    </tr>
                    <tr>
                        <td><code>std::move</code></td>
                        <td>소유권 이동</td>
                        <td>원본 더 이상 안 쓸 때</td>
                    </tr>
                </table>
            </div>
        </section>

        <footer class="footer">
            <p>MSH Portfolio - Server Developer</p>
        </footer>
    </div>
</body>
</html>
