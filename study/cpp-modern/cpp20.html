<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++20 Features - 서버 개발자를 위한 Modern C++</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e4e4e4;
            line-height: 1.7;
        }
        .container { max-width: 900px; margin: 0 auto; padding: 40px 20px; }

        .nav {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }
        .nav a {
            color: #888;
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s;
        }
        .nav a:hover { color: #667eea; }

        .header {
            text-align: center;
            margin-bottom: 50px;
        }
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .header p { color: #888; font-size: 1.1rem; }

        .intro-box {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 40px;
        }
        .intro-box h3 {
            color: #667eea;
            margin-bottom: 12px;
        }
        .intro-box ul {
            list-style: none;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
        }
        .intro-box li {
            color: #aaa;
            font-size: 0.95rem;
        }
        .intro-box li::before {
            content: "→ ";
            color: #667eea;
        }

        .section {
            background: rgba(255,255,255,0.03);
            border-radius: 16px;
            padding: 32px;
            margin-bottom: 32px;
            border: 1px solid rgba(255,255,255,0.06);
        }
        .section h2 {
            color: #667eea;
            font-size: 1.5rem;
            margin-bottom: 24px;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(102, 126, 234, 0.3);
        }

        .question-box {
            background: rgba(255, 193, 7, 0.1);
            border-left: 4px solid #ffc107;
            padding: 16px 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        .question-box::before {
            content: "Q. ";
            font-weight: 700;
            color: #ffc107;
        }

        .answer-box {
            background: rgba(76, 175, 80, 0.1);
            border-left: 4px solid #4caf50;
            padding: 16px 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        .answer-box::before {
            content: "A. ";
            font-weight: 700;
            color: #4caf50;
        }

        .thinking-box {
            background: rgba(33, 150, 243, 0.1);
            border-left: 4px solid #2196f3;
            padding: 16px 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
            font-style: italic;
        }
        .thinking-box::before {
            content: "생각: ";
            font-weight: 700;
            color: #2196f3;
            font-style: normal;
        }

        .deep-box {
            background: rgba(156, 39, 176, 0.1);
            border-left: 4px solid #9c27b0;
            padding: 16px 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        .deep-box::before {
            content: "심화: ";
            font-weight: 700;
            color: #9c27b0;
        }

        pre {
            background: #0d1117;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin: 16px 0;
            border: 1px solid #30363d;
        }
        code {
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9rem;
            color: #e6edf3;
        }
        .keyword { color: #ff7b72; }
        .type { color: #79c0ff; }
        .string { color: #a5d6ff; }
        .comment { color: #8b949e; }
        .function { color: #d2a8ff; }
        .number { color: #79c0ff; }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .comparison-table th, .comparison-table td {
            padding: 12px;
            text-align: left;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .comparison-table th {
            background: rgba(102, 126, 234, 0.2);
            color: #667eea;
        }
        .comparison-table td {
            background: rgba(255,255,255,0.02);
        }

        .highlight {
            background: rgba(102, 126, 234, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            color: #667eea;
        }

        .practical-box {
            background: rgba(255, 152, 0, 0.1);
            border: 1px solid rgba(255, 152, 0, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .practical-box h4 {
            color: #ff9800;
            margin-bottom: 8px;
        }

        .footer {
            text-align: center;
            padding: 40px 0;
            color: #666;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav">
            <a href="./">&larr; 목록</a>
            <a href="./cpp11.html">C++11</a>
            <a href="./cpp14.html">C++14</a>
            <a href="./cpp17.html">C++17</a>
            <a href="./cpp20.html" style="color: #667eea; font-weight: 600;">C++20</a>
        </nav>

        <header class="header">
            <h1>C++20 Features</h1>
            <p>서버 개발자를 위한 Modern C++ - 대화로 배우는 핵심 기능</p>
        </header>

        <div class="intro-box">
            <h3>C++20 핵심 기능</h3>
            <ul>
                <li>Concepts (템플릿 제약)</li>
                <li>Coroutines (co_await)</li>
                <li>std::span (메모리 뷰)</li>
                <li>Three-way comparison (<=>)</li>
                <li>std::format (포맷팅)</li>
                <li>Ranges (파이프라인)</li>
            </ul>
        </div>

        <!-- Concepts -->
        <div class="section">
            <h2>1. Concepts - 템플릿 제약조건</h2>

            <div class="question-box">
                C++17까지 템플릿 쓰면서 에러 메시지가 엄청 길고 이해하기 어려웠던 적 있어? 템플릿 함수를 호출할 때 "이 타입은 + 연산이 가능해야 해"라고 미리 제약을 걸 수 있다면?
            </div>

            <pre><code><span class="comment">// 기존 - 아무 타입이나 들어옴</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">T</span>&gt;
<span class="type">T</span> <span class="function">add</span>(<span class="type">T</span> a, <span class="type">T</span> b) {
    <span class="keyword">return</span> a + b;  <span class="comment">// + 없으면 여기서 에러 (깊숙한 곳에서)</span>
}</code></pre>

            <div class="answer-box">
                C++20에서는 Concepts로 함수 선언부에서 "T는 이런 조건이어야 해"라고 명시할 수 있어!
            </div>

            <pre><code><span class="comment">// C++20 - 조건을 명시</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">T</span>&gt;
    <span class="keyword">requires</span> std::integral&lt;<span class="type">T</span>&gt; || std::floating_point&lt;<span class="type">T</span>&gt;
<span class="type">T</span> <span class="function">add</span>(<span class="type">T</span> a, <span class="type">T</span> b) {
    <span class="keyword">return</span> a + b;
}

<span class="function">add</span>(<span class="number">1</span>, <span class="number">2</span>);        <span class="comment">// OK (int는 integral)</span>
<span class="function">add</span>(<span class="number">1.5</span>, <span class="number">2.5</span>);    <span class="comment">// OK (double은 floating_point)</span>
<span class="function">add</span>(vec1, vec2);  <span class="comment">// 호출 시점에서 바로 에러! "조건 안 맞음"</span></code></pre>

            <div class="question-box">
                그럼 std::integral 같은 조건은 누가 만들어 놓은 거야? 직접 만들 수도 있어?
            </div>

            <div class="answer-box">
                표준 라이브러리에 미리 정의된 것들이 있고, 직접 만들 수도 있어!
            </div>

            <pre><code><span class="comment">// 표준 라이브러리 제공</span>
<span class="keyword">#include</span> <span class="string">&lt;concepts&gt;</span>

std::integral&lt;<span class="type">T</span>&gt;       <span class="comment">// int, long, short 등 정수형</span>
std::floating_point&lt;<span class="type">T</span>&gt; <span class="comment">// float, double 등 실수형</span>
std::same_as&lt;<span class="type">T</span>, <span class="type">U</span>&gt;     <span class="comment">// T와 U가 같은 타입</span>
std::copyable&lt;<span class="type">T</span>&gt;       <span class="comment">// 복사 가능한 타입</span>

<span class="comment">// 직접 만들기 - "덧셈 가능한 타입"</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">T</span>&gt;
<span class="keyword">concept</span> <span class="type">Addable</span> = <span class="keyword">requires</span>(<span class="type">T</span> a, <span class="type">T</span> b) {
    { a + b } -> std::same_as&lt;<span class="type">T</span>&gt;;  <span class="comment">// a + b 가능하고, 결과도 T</span>
};

<span class="comment">// 사용</span>
<span class="keyword">template</span>&lt;<span class="type">Addable</span> <span class="type">T</span>&gt;
<span class="type">T</span> <span class="function">add</span>(<span class="type">T</span> a, <span class="type">T</span> b);</code></pre>

            <div class="practical-box">
                <h4>서버 개발자 관점</h4>
                <ul>
                    <li>템플릿 에러 메시지가 명확해짐</li>
                    <li>API 설계할 때 "이 함수는 이런 타입만 받아" 명시 가능</li>
                    <li>코드 문서화 효과</li>
                </ul>
            </div>
        </div>

        <!-- Coroutines -->
        <div class="section">
            <h2>2. Coroutines - 비동기를 동기처럼</h2>

            <div class="question-box">
                서버에서 비동기 I/O 처리할 때 콜백 지옥 겪어본 적 있어?
            </div>

            <pre><code><span class="comment">// 콜백 지옥 - DB 쿼리 3개를 순서대로</span>
db.<span class="function">query</span>(<span class="string">"1번"</span>, [](<span class="type">Result</span> r1) {
    db.<span class="function">query</span>(<span class="string">"2번"</span>, [r1](<span class="type">Result</span> r2) {
        db.<span class="function">query</span>(<span class="string">"3번"</span>, [r1, r2](<span class="type">Result</span> r3) {
            <span class="function">use</span>(r1, r2, r3);  <span class="comment">// 점점 깊어짐...</span>
        });
    });
});</code></pre>

            <div class="thinking-box">
                난 폴링 방식을 알고 있는데, 콜백 지옥이 뭐야?
            </div>

            <div class="answer-box">
                <strong>폴링</strong>: 내가 직접 "패킷 왔니?" 확인하러 감<br>
                <strong>콜백</strong>: "패킷 오면 이 함수 불러줘" 등록해둠. 순차 처리가 필요하면 콜백 안에 콜백 안에 콜백... 지옥!
            </div>

            <div class="question-box">
                비동기인데(블로킹 안 하고) 동기 코드처럼 순차적으로 쓸 수 있으면 좋지 않아?
            </div>

            <pre><code><span class="comment">// C++20 코루틴 - 동기처럼 읽힘</span>
<span class="type">Result</span> r1 = <span class="keyword">co_await</span> db.<span class="function">query</span>(<span class="string">"1번"</span>);
<span class="type">Result</span> r2 = <span class="keyword">co_await</span> db.<span class="function">query</span>(<span class="string">"2번"</span>);
<span class="type">Result</span> r3 = <span class="keyword">co_await</span> db.<span class="function">query</span>(<span class="string">"3번"</span>);
<span class="function">use</span>(r1, r2, r3);</code></pre>

            <div class="answer-box">
                <code>co_await</code> = "기다려, 근데 블로킹 아니야"
            </div>

            <div class="thinking-box">
                함수를 일시정지한다는 개념은 뭐고, 결과 도착해서 멈췄던 곳부터 재개한다는 게 무슨 말이지?
            </div>

            <div class="deep-box">
                <strong>일반 함수 vs 코루틴의 핵심 차이</strong><br><br>
                <strong>일반 함수:</strong> 한번 들어가면 끝날 때까지 못 나와<br>
                <strong>코루틴:</strong> co_await 만나면 함수 중간에 나갈 수 있고, 나중에 그 지점부터 다시 시작
            </div>

            <pre><code><span class="keyword">void</span> <span class="function">processUser</span>() {
    cout << <span class="string">"1. 유저 정보 요청"</span>;

    <span class="type">UserInfo</span> info = <span class="keyword">co_await</span> db.<span class="function">getUser</span>(<span class="number">123</span>);  <span class="comment">// ⚡ 여기서 나감</span>

    cout << <span class="string">"2. 유저 정보 받음: "</span> << info.name;
}

<span class="comment">// 실행 흐름:</span>
<span class="comment">// [0ms] "1. 유저 정보 요청" 출력</span>
<span class="comment">// [0ms] co_await 만남 → DB에 요청 보내고 함수에서 나감</span>
<span class="comment">// [0ms] 이 스레드는 다른 일 함 (안 기다림!)</span>
<span class="comment">//</span>
<span class="comment">// ... DB가 열심히 쿼리 중 ...</span>
<span class="comment">//</span>
<span class="comment">// [50ms] DB 응답 도착</span>
<span class="comment">// [50ms] 아까 멈췄던 곳으로 돌아감</span>
<span class="comment">// [50ms] "2. 유저 정보 받음: 철수" 출력</span></code></pre>

            <div class="question-box">
                그럼 co_await 할 때 스택 프레임은 어떻게 되는 거지? CS적으로 알고 싶어.
            </div>

            <div class="answer-box">
                핵심: <strong>스택 대신 힙에 프레임을 두니까</strong> 나갔다 들어올 수 있는 거야!
            </div>

            <table class="comparison-table">
                <tr>
                    <th></th>
                    <th>일반 함수</th>
                    <th>코루틴</th>
                </tr>
                <tr>
                    <td>상태 저장</td>
                    <td>스택</td>
                    <td>힙</td>
                </tr>
                <tr>
                    <td>중간에 나가면</td>
                    <td>상태 소멸</td>
                    <td>상태 유지</td>
                </tr>
                <tr>
                    <td>리턴 후 재진입</td>
                    <td>불가능</td>
                    <td>가능</td>
                </tr>
            </table>

            <pre><code><span class="comment">// 일반 함수</span>
<span class="comment">//   Stack: [frame] ← 리턴하면 pop되어 사라짐</span>

<span class="comment">// 코루틴</span>
<span class="comment">//   Heap: [코루틴 프레임] ← co_await 해도 안 사라짐</span>
<span class="comment">//         (지역변수, 실행위치 저장)</span></code></pre>

            <div class="deep-box">
                <strong>코루틴 프레임에 저장되는 것들:</strong>
                <ol>
                    <li>지역 변수들 (userId, info 등)</li>
                    <li>어디서 멈췄는지 (재개 지점)</li>
                    <li>promise 객체 (결과 주고받는 용도)</li>
                </ol>
            </div>

            <div class="question-box">
                그럼 co_await 된 곳에서 나중에 다시 와야 한다면, 그 아래 코드는 하나도 실행 안 되겠네?
            </div>

            <div class="answer-box">
                정확해! 스레드가 함수를 빠져나오고, 힙에 프레임 저장하고, 나중에 결과 오면 그 지점부터 재개해.
            </div>

            <pre><code><span class="type">Task</span> <span class="function">process</span>() {
    cout << <span class="string">"A"</span>;                          <span class="comment">// 1. 실행됨</span>
    <span class="type">Result</span> r1 = <span class="keyword">co_await</span> db.<span class="function">query</span>(<span class="string">"1번"</span>);  <span class="comment">// 2. 여기서 나감!</span>
    cout << <span class="string">"B"</span>;                          <span class="comment">// ❌ 아직 실행 안 됨</span>
    cout << <span class="string">"C"</span>;                          <span class="comment">// ❌ 아직 실행 안 됨</span>
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="function">process</span>();          <span class="comment">// 코루틴 시작</span>
    cout << <span class="string">"D"</span>;        <span class="comment">// 3. 이게 먼저 실행됨!</span>
}

<span class="comment">// 출력 순서: A → D → (시간 흐름) → B → C</span></code></pre>

            <table class="comparison-table">
                <tr>
                    <th>방식</th>
                    <th>스레드 블로킹</th>
                    <th>코드 가독성</th>
                </tr>
                <tr>
                    <td>동기</td>
                    <td>멈춤 (성능 구림)</td>
                    <td>깔끔</td>
                </tr>
                <tr>
                    <td>콜백</td>
                    <td>안 멈춤 (성능 좋음)</td>
                    <td>지옥</td>
                </tr>
                <tr>
                    <td>코루틴</td>
                    <td>안 멈춤 (성능 좋음)</td>
                    <td>깔끔 ✅</td>
                </tr>
            </table>
        </div>

        <!-- std::span -->
        <div class="section">
            <h2>3. std::span - 연속 메모리 통합 뷰</h2>

            <div class="question-box">
                서버에서 버퍼 처리할 때 같은 "연속된 메모리"인데 타입마다 함수를 따로 만들어야 했던 적 있어?
            </div>

            <pre><code><span class="comment">// 기존 - 같은 로직인데 오버로딩 3개</span>
<span class="keyword">void</span> <span class="function">processPacket</span>(<span class="type">char</span>* data, <span class="type">size_t</span> size);           <span class="comment">// 포인터 + 크기</span>
<span class="keyword">void</span> <span class="function">processPacket</span>(std::vector&lt;<span class="type">char</span>&gt;& buffer);         <span class="comment">// 벡터</span>
<span class="keyword">void</span> <span class="function">processPacket</span>(std::array&lt;<span class="type">char</span>, <span class="number">1024</span>&gt;& buffer);    <span class="comment">// 배열</span></code></pre>

            <div class="thinking-box">
                왜 이렇게 여러 개 만들어야 하지?
            </div>

            <div class="answer-box">
                서버에서 패킷 데이터가 들어오는 경로가 다양하기 때문이야!
            </div>

            <pre><code><span class="comment">// 1. 소켓에서 직접 받은 경우 (C 스타일)</span>
<span class="type">char</span> rawBuffer[<span class="number">1024</span>];
<span class="type">int</span> bytesRead = <span class="function">recv</span>(socket, rawBuffer, <span class="number">1024</span>, <span class="number">0</span>);
<span class="function">processPacket</span>(rawBuffer, bytesRead);  <span class="comment">// 포인터 + 크기</span>

<span class="comment">// 2. 이미 vector로 관리하는 경우</span>
std::vector&lt;<span class="type">char</span>&gt; packetBuffer;
<span class="function">processPacket</span>(packetBuffer);  <span class="comment">// 벡터</span>

<span class="comment">// 3. 고정 크기 버퍼 쓰는 경우</span>
std::array&lt;<span class="type">char</span>, <span class="number">1024</span>&gt; fixedBuffer;
<span class="function">processPacket</span>(fixedBuffer);  <span class="comment">// array</span></code></pre>

            <div class="question-box">
                포인터+크기, vector, array 전부 하나의 타입으로 받을 수 있다면?
            </div>

            <pre><code><span class="comment">// C++20 std::span - 이거 하나로 다 받음</span>
<span class="keyword">void</span> <span class="function">processPacket</span>(std::span&lt;<span class="type">char</span>&gt; buffer);

<span class="type">char</span> arr[<span class="number">100</span>];
std::vector&lt;<span class="type">char</span>&gt; vec(<span class="number">100</span>);
std::array&lt;<span class="type">char</span>, <span class="number">100</span>&gt; stdArr;

<span class="function">processPacket</span>(arr);      <span class="comment">// OK</span>
<span class="function">processPacket</span>(vec);      <span class="comment">// OK</span>
<span class="function">processPacket</span>(stdArr);   <span class="comment">// OK</span></code></pre>

            <div class="thinking-box">
                span이 어떻게 이걸 가능하게 하는지 원리가 연결이 안 돼.
            </div>

            <div class="answer-box">
                핵심: vector, array, C배열 다 내부는 <strong>"시작 주소 + 크기"</strong>로 표현 가능해!
            </div>

            <pre><code><span class="comment">// span 내부 구조 (대략)</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">T</span>&gt;
<span class="keyword">class</span> <span class="type">span</span> {
    <span class="type">T</span>* ptr;        <span class="comment">// 시작 주소</span>
    <span class="type">size_t</span> size;   <span class="comment">// 크기</span>
};</code></pre>

            <pre><code><span class="comment">// 각 타입에서 span으로 변환</span>
std::vector&lt;<span class="type">char</span>&gt; vec(<span class="number">100</span>);
std::span&lt;<span class="type">char</span>&gt; s1 = vec;
<span class="comment">// s1.ptr  = vec.data()   → 0x1000</span>
<span class="comment">// s1.size = vec.size()   → 100</span>

std::array&lt;<span class="type">char</span>, <span class="number">100</span>&gt; arr;
std::span&lt;<span class="type">char</span>&gt; s2 = arr;
<span class="comment">// s2.ptr  = arr.data()   → 0x2000</span>
<span class="comment">// s2.size = 100</span>

<span class="type">char</span> cArr[<span class="number">100</span>];
std::span&lt;<span class="type">char</span>&gt; s3 = cArr;
<span class="comment">// s3.ptr  = &cArr[0]     → 0x3000</span>
<span class="comment">// s3.size = 100</span></code></pre>

            <pre><code><span class="comment">// 그림으로 보면:</span>
<span class="comment">//</span>
<span class="comment">// vector:  [ptr]──→ [■■■■■■■■■■] 메모리</span>
<span class="comment">//                   ↑</span>
<span class="comment">// span:    [ptr, size=100] ──┘</span>
<span class="comment">//</span>
<span class="comment">// array:   [■■■■■■■■■■] 메모리</span>
<span class="comment">//           ↑</span>
<span class="comment">// span:    [ptr, size=100] ──┘</span>
<span class="comment">//</span>
<span class="comment">// span은 원본을 "가리키기만" 해. 복사 안 함.</span></code></pre>

            <div class="answer-box">
                <strong>요약:</strong><br>
                1. vector, array, C배열 다 "연속 메모리"<br>
                2. span은 {포인터, 크기}만 저장<br>
                3. 각 타입에서 span으로 자동 변환 가능 (생성자가 있음)<br>
                4. 함수는 span만 받으면 원본 타입 몰라도 됨
            </div>
        </div>

        <!-- Three-way comparison -->
        <div class="section">
            <h2>4. Three-way comparison (우주선 연산자)</h2>

            <div class="question-box">
                클래스에 비교 연산자 만들어본 적 있어? 6개나 만들어야 해서 귀찮지 않았어?
            </div>

            <pre><code><span class="keyword">struct</span> <span class="type">Player</span> {
    <span class="type">int</span> level;
    <span class="type">int</span> exp;
};

<span class="comment">// 기존 - 6개 다 만들어야 했음</span>
<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="type">Player</span>& a, <span class="keyword">const</span> <span class="type">Player</span>& b);
<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> <span class="type">Player</span>& a, <span class="keyword">const</span> <span class="type">Player</span>& b);
<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="type">Player</span>& a, <span class="keyword">const</span> <span class="type">Player</span>& b);
<span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> <span class="type">Player</span>& a, <span class="keyword">const</span> <span class="type">Player</span>& b);
<span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="type">Player</span>& a, <span class="keyword">const</span> <span class="type">Player</span>& b);
<span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> <span class="type">Player</span>& a, <span class="keyword">const</span> <span class="type">Player</span>& b);</code></pre>

            <div class="thinking-box">
                편하긴 하겠다. 근데 규칙이 있어야 할 것 같은데.
            </div>

            <div class="answer-box">
                맞아! C++20에서는 <code>&lt;=&gt;</code> 우주선 연산자 하나로 6개 자동 생성!
            </div>

            <pre><code><span class="keyword">struct</span> <span class="type">Player</span> {
    <span class="type">int</span> level;
    <span class="type">int</span> exp;

    <span class="keyword">auto</span> <span class="keyword">operator</span>&lt;=&gt;(<span class="keyword">const</span> <span class="type">Player</span>&) <span class="keyword">const</span> = <span class="keyword">default</span>;  <span class="comment">// 이거 하나로 끝!</span>
};

<span class="type">Player</span> a{<span class="number">10</span>, <span class="number">500</span>};
<span class="type">Player</span> b{<span class="number">10</span>, <span class="number">300</span>};

a == b;   <span class="comment">// OK</span>
a != b;   <span class="comment">// OK</span>
a &lt; b;    <span class="comment">// OK</span>
a &lt;= b;   <span class="comment">// OK</span>
a &gt; b;    <span class="comment">// OK</span>
a &gt;= b;   <span class="comment">// OK</span></code></pre>

            <div class="deep-box">
                <strong>규칙 (= default일 때):</strong> 멤버 변수를 선언 순서대로 비교<br><br>
                <code>Player{10, 500} &lt;=&gt; Player{10, 300}</code><br>
                1. level 비교: 10 vs 10 → 같음, 다음으로<br>
                2. exp 비교: 500 vs 300 → a가 큼<br>
                결과: a > b
            </div>

            <div class="question-box">
                정수 타입이어야 한다거나 하는 제약조건이 있지 않을까?
            </div>

            <div class="answer-box">
                좋은 질문! 멤버들도 <code>&lt;=&gt;</code> 가능해야 해.
            </div>

            <pre><code><span class="keyword">struct</span> <span class="type">Player</span> {
    <span class="type">int</span> level;              <span class="comment">// int는 <=> 가능 ✅</span>
    std::string name;       <span class="comment">// string도 <=> 가능 ✅</span>

    <span class="keyword">auto</span> <span class="keyword">operator</span>&lt;=&gt;(<span class="keyword">const</span> <span class="type">Player</span>&) <span class="keyword">const</span> = <span class="keyword">default</span>;  <span class="comment">// OK</span>
};

<span class="keyword">struct</span> <span class="type">Enemy</span> {
    <span class="type">int</span> hp;
    <span class="type">SomeWeirdClass</span> data;    <span class="comment">// <=> 없는 타입 ❌</span>

    <span class="keyword">auto</span> <span class="keyword">operator</span>&lt;=&gt;(<span class="keyword">const</span> <span class="type">Enemy</span>&) <span class="keyword">const</span> = <span class="keyword">default</span>;  <span class="comment">// 컴파일 에러!</span>
};</code></pre>

            <div class="deep-box">
                <strong>비교 종류 (ordering):</strong><br>
                <code>std::strong_ordering</code> - 완전한 순서 (int, string 등)<br>
                <code>std::weak_ordering</code> - 동등하지만 구분 가능<br>
                <code>std::partial_ordering</code> - 비교 불가능한 경우 있음 (float의 NaN)
            </div>
        </div>

        <!-- std::format -->
        <div class="section">
            <h2>5. std::format - 포맷 문자열</h2>

            <pre><code><span class="comment">// 기존 방식들</span>
std::cout << <span class="string">"Player "</span> << name << <span class="string">" (Lv."</span> << level << <span class="string">") HP: "</span> << hp;
<span class="function">sprintf</span>(buf, <span class="string">"Player %s (Lv.%d) HP: %d"</span>, name.<span class="function">c_str</span>(), level, hp);

<span class="comment">// C++20 std::format</span>
std::string msg = std::<span class="function">format</span>(<span class="string">"Player {} (Lv.{}) HP: {}/{}"</span>, name, level, hp, maxHp);

<span class="comment">// 포맷 지정</span>
std::<span class="function">format</span>(<span class="string">"{:.2f}"</span>, <span class="number">3.14159</span>);     <span class="comment">// "3.14" (소수점 2자리)</span>
std::<span class="function">format</span>(<span class="string">"{:08d}"</span>, <span class="number">42</span>);          <span class="comment">// "00000042" (8자리, 0채움)</span>
std::<span class="function">format</span>(<span class="string">"{:>10}"</span>, <span class="string">"hi"</span>);        <span class="comment">// "        hi" (오른쪽 정렬)</span></code></pre>

            <div class="practical-box">
                <h4>현실</h4>
                타입 안전하고 읽기 쉬운 장점이 있지만, 기존 코드베이스들이 printf나 자체 로깅 라이브러리 쓰고 있어서 아직 많이 안 쓰임.
            </div>
        </div>

        <!-- Ranges -->
        <div class="section">
            <h2>6. Ranges - 파이프라인 처리</h2>

            <pre><code><span class="comment">// 기존 - for문으로 필터링 + 변환</span>
std::vector&lt;<span class="type">Player</span>&gt; players;
std::vector&lt;std::string&gt; names;
<span class="keyword">for</span> (<span class="keyword">const auto</span>& p : players) {
    <span class="keyword">if</span> (p.level >= <span class="number">10</span>) {
        names.<span class="function">push_back</span>(p.name);
    }
}

<span class="comment">// C++20 Ranges - 파이프로 체이닝</span>
<span class="keyword">auto</span> names = players
    | std::views::<span class="function">filter</span>([](<span class="keyword">const</span> <span class="type">Player</span>& p) { <span class="keyword">return</span> p.level >= <span class="number">10</span>; })
    | std::views::<span class="function">transform</span>([](<span class="keyword">const</span> <span class="type">Player</span>& p) { <span class="keyword">return</span> p.name; });</code></pre>

            <div class="practical-box">
                <h4>현실</h4>
                함수형 프로그래밍 좋아하는 사람들은 좋아함. 근데 서버 코드에서? 기존 for문이 더 직관적인 경우 많음. 컴파일 시간도 늘어나고 디버깅도 더 어려움.<br><br>
                <strong>결론: 알아두면 좋지만 필수는 아님.</strong>
            </div>
        </div>

        <footer class="footer">
            Modern C++ 학습 시리즈 | 대화로 배우는 C++20
        </footer>
    </div>
</body>
</html>
