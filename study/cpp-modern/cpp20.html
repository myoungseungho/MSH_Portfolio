<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++20 Features - MSH Portfolio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.8;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 60px 20px;
        }

        .nav {
            margin-bottom: 40px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .nav a {
            color: #666;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .nav a:hover {
            color: #333;
        }

        .header {
            margin-bottom: 50px;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 16px;
            color: #111;
        }

        .header-meta {
            display: flex;
            gap: 20px;
            color: #666;
            font-size: 0.9rem;
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 20px 0;
        }

        .tag {
            background: #e8f4fd;
            color: #1976d2;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .section {
            margin-bottom: 50px;
        }

        .section h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #111;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .section h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 30px 0 15px 0;
            color: #333;
        }

        .section p {
            margin-bottom: 16px;
            color: #444;
        }

        .question-box {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            border-left: 4px solid #667eea;
            padding: 20px;
            border-radius: 0 12px 12px 0;
            margin: 25px 0;
        }

        .question-box .q-label {
            color: #667eea;
            font-weight: 700;
            font-size: 0.85rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .question-box .q-label::before {
            content: "Q";
            background: #667eea;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .question-box .question {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
        }

        .thinking-box {
            background: #fff8e1;
            border-left: 4px solid #ffb300;
            padding: 20px;
            border-radius: 0 12px 12px 0;
            margin: 20px 0;
        }

        .thinking-box .t-label {
            color: #f57c00;
            font-weight: 700;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .answer-box {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 20px;
            border-radius: 0 12px 12px 0;
            margin: 20px 0;
        }

        .answer-box .a-label {
            color: #2e7d32;
            font-weight: 700;
            font-size: 0.85rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .answer-box .a-label::before {
            content: "A";
            background: #4caf50;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .insight-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin: 20px 0;
        }

        .insight-box h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .insight-box.blue {
            background: #e3f2fd;
            border-left-color: #2196f3;
        }

        .insight-box.blue h4 {
            color: #1565c0;
        }

        .insight-box.green {
            background: #e8f5e9;
            border-left-color: #4caf50;
        }

        .insight-box.green h4 {
            color: #2e7d32;
        }

        .insight-box.red {
            background: #ffebee;
            border-left-color: #f44336;
        }

        .insight-box.red h4 {
            color: #c62828;
        }

        ul, ol {
            margin: 16px 0;
            padding-left: 24px;
        }

        li {
            margin-bottom: 8px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }

        th, td {
            padding: 14px 16px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background: #f8f8f8;
            font-weight: 600;
            color: #333;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .footer {
            text-align: center;
            padding: 40px 0;
            color: #999;
            font-size: 0.9rem;
            border-top: 1px solid #e0e0e0;
            margin-top: 60px;
        }

        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }

        pre code {
            background: none;
            padding: 0;
        }

        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            font-weight: 700;
            font-size: 0.9rem;
            margin-right: 10px;
        }

        .compare-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        @media (max-width: 600px) {
            .compare-grid {
                grid-template-columns: 1fr;
            }
        }

        .compare-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            border: 1px solid #eee;
        }

        .compare-card h4 {
            font-size: 1rem;
            margin-bottom: 12px;
            color: #333;
        }

        .compare-card.old {
            border-top: 3px solid #f44336;
        }

        .compare-card.new {
            border-top: 3px solid #4caf50;
        }

        .diagram {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 24px;
            margin: 20px 0;
            font-family: 'Consolas', monospace;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.4;
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav">
            <a href="./">&larr; 목록</a>
            <a href="./cpp11.html">C++11</a>
            <a href="./cpp14.html">C++14</a>
            <a href="./cpp17.html">C++17</a>
            <a href="./cpp20.html" style="color: #667eea; font-weight: 600;">C++20</a>
            <a href="./rust.html" style="color: #f74c00;">Rust</a>
        </nav>

        <header class="header">
            <h1>C++20 Features</h1>
            <div class="header-meta">
                <span>Modern C++</span>
                <span>Language Features</span>
            </div>
            <div class="tags">
                <span class="tag">C++20</span>
                <span class="tag">Concepts</span>
                <span class="tag">Coroutines</span>
                <span class="tag">std::span</span>
                <span class="tag">&lt;=&gt;</span>
            </div>
        </header>

        <!-- 개요 -->
        <section class="section">
            <h2>개요</h2>
            <p>
                C++20은 C++11 이후 가장 큰 변화를 가져온 버전입니다.
                <strong>Concepts, Coroutines, Ranges</strong> 등 대규모 기능이 추가되었습니다.
                실무에서 바로 쓸 수 있는 것들을 중심으로 학습합니다.
            </p>
        </section>

        <!-- 1. Concepts -->
        <section class="section">
            <h2><span class="step-number">1</span>Concepts - 템플릿 제약조건</h2>

            <div class="question-box">
                <div class="q-label">질문</div>
                <div class="question">
                    템플릿 에러 메시지가 엄청 길고 이해하기 어려웠던 적 있어? "이 타입은 + 연산이 가능해야 해"라고 미리 제약을 걸 수 있다면?
                </div>
            </div>

<pre><code>// 기존 - 아무 타입이나 들어옴
template&lt;typename T&gt;
T add(T a, T b) {
    return a + b;  // + 없으면 여기서 에러 (깊숙한 곳에서)
}</code></pre>

            <div class="answer-box">
                <div class="a-label">C++20 Concepts</div>
<pre><code>// 조건을 명시
template&lt;typename T&gt;
    requires std::integral&lt;T&gt; || std::floating_point&lt;T&gt;
T add(T a, T b) {
    return a + b;
}

add(1, 2);        // OK (int는 integral)
add(1.5, 2.5);    // OK (double은 floating_point)
add(vec1, vec2);  // 호출 시점에서 바로 에러! "조건 안 맞음"</code></pre>
            </div>

            <div class="question-box">
                <div class="q-label">추가 질문</div>
                <div class="question">
                    그럼 std::integral 같은 조건은 누가 만들어 놓은 거야? 직접 만들 수도 있어?
                </div>
            </div>

            <div class="answer-box">
                <div class="a-label">표준 라이브러리 + 직접 정의</div>
<pre><code>// 표준 라이브러리 제공
#include &lt;concepts&gt;
std::integral&lt;T&gt;       // int, long, short 등 정수형
std::floating_point&lt;T&gt; // float, double 등 실수형
std::same_as&lt;T, U&gt;     // T와 U가 같은 타입
std::copyable&lt;T&gt;       // 복사 가능한 타입

// 직접 만들기 - "덧셈 가능한 타입"
template&lt;typename T&gt;
concept Addable = requires(T a, T b) {
    { a + b } -&gt; std::same_as&lt;T&gt;;
};

// 사용
template&lt;Addable T&gt;
T add(T a, T b);</code></pre>
            </div>

            <div class="insight-box green">
                <h4>서버 개발자 관점</h4>
                <ul>
                    <li>템플릿 에러 메시지가 명확해짐</li>
                    <li>API 설계할 때 "이 함수는 이런 타입만 받아" 명시 가능</li>
                    <li>코드 문서화 효과</li>
                </ul>
            </div>
        </section>

        <!-- 2. Coroutines -->
        <section class="section">
            <h2><span class="step-number">2</span>Coroutines - 비동기를 동기처럼</h2>

            <div class="question-box">
                <div class="q-label">질문</div>
                <div class="question">
                    서버에서 비동기 I/O 처리할 때 콜백 지옥 겪어본 적 있어?
                </div>
            </div>

<pre><code>// 콜백 지옥 - DB 쿼리 3개를 순서대로
db.query("1번", [](Result r1) {
    db.query("2번", [r1](Result r2) {
        db.query("3번", [r1, r2](Result r3) {
            use(r1, r2, r3);  // 점점 깊어짐...
        });
    });
});</code></pre>

            <div class="thinking-box">
                <div class="t-label">콜백 vs 폴링?</div>
                <p><strong>폴링</strong>: 내가 직접 "패킷 왔니?" 확인하러 감</p>
                <p><strong>콜백</strong>: "패킷 오면 이 함수 불러줘" 등록해둠. 순차 처리가 필요하면 콜백 안에 콜백 안에 콜백... 지옥!</p>
            </div>

            <div class="answer-box">
                <div class="a-label">C++20 코루틴</div>
<pre><code>// 동기처럼 읽힘
Result r1 = co_await db.query("1번");
Result r2 = co_await db.query("2번");
Result r3 = co_await db.query("3번");
use(r1, r2, r3);</code></pre>
                <p><code>co_await</code> = "기다려, 근데 블로킹 아니야"</p>
            </div>

            <div class="question-box">
                <div class="q-label">추가 질문</div>
                <div class="question">
                    함수를 일시정지한다는 개념은 뭐고, 결과 도착해서 멈췄던 곳부터 재개한다는 게 무슨 말이지?
                </div>
            </div>

            <div class="insight-box blue">
                <h4>일반 함수 vs 코루틴</h4>
                <p><strong>일반 함수:</strong> 한번 들어가면 끝날 때까지 못 나와</p>
                <p><strong>코루틴:</strong> co_await 만나면 함수 중간에 나갈 수 있고, 나중에 그 지점부터 다시 시작</p>
            </div>

<pre><code>void processUser() {
    cout &lt;&lt; "1. 유저 정보 요청";

    UserInfo info = co_await db.getUser(123);  // 여기서 나감!

    cout &lt;&lt; "2. 유저 정보 받음: " &lt;&lt; info.name;
}

// 실행 흐름:
// [0ms] "1. 유저 정보 요청" 출력
// [0ms] co_await → DB에 요청 보내고 함수에서 나감
// [0ms] 스레드는 다른 일 함 (안 기다림!)
// ... DB가 쿼리 중 ...
// [50ms] DB 응답 도착 → 멈췄던 곳부터 재개
// [50ms] "2. 유저 정보 받음" 출력</code></pre>

            <div class="question-box">
                <div class="q-label">CS 질문</div>
                <div class="question">
                    그럼 co_await 할 때 스택 프레임은 어떻게 되는 거지?
                </div>
            </div>

            <div class="answer-box">
                <div class="a-label">스택 대신 힙!</div>
                <p>핵심: <strong>스택 대신 힙에 프레임을 두니까</strong> 나갔다 들어올 수 있는 거야!</p>
            </div>

            <table>
                <tr>
                    <th></th>
                    <th>일반 함수</th>
                    <th>코루틴</th>
                </tr>
                <tr>
                    <td>상태 저장</td>
                    <td>스택</td>
                    <td>힙</td>
                </tr>
                <tr>
                    <td>중간에 나가면</td>
                    <td>상태 소멸</td>
                    <td>상태 유지</td>
                </tr>
                <tr>
                    <td>리턴 후 재진입</td>
                    <td>불가능</td>
                    <td>가능</td>
                </tr>
            </table>

            <table>
                <tr>
                    <th>방식</th>
                    <th>스레드 블로킹</th>
                    <th>코드 가독성</th>
                </tr>
                <tr>
                    <td>동기</td>
                    <td>멈춤 (성능 구림)</td>
                    <td>깔끔</td>
                </tr>
                <tr>
                    <td>콜백</td>
                    <td>안 멈춤 (성능 좋음)</td>
                    <td>지옥</td>
                </tr>
                <tr>
                    <td>코루틴</td>
                    <td>안 멈춤 (성능 좋음)</td>
                    <td>깔끔 ✓</td>
                </tr>
            </table>
        </section>

        <!-- 3. std::span -->
        <section class="section">
            <h2><span class="step-number">3</span>std::span - 연속 메모리 통합 뷰</h2>

            <div class="question-box">
                <div class="q-label">질문</div>
                <div class="question">
                    서버에서 버퍼 처리할 때 같은 "연속된 메모리"인데 타입마다 함수를 따로 만들어야 했던 적 있어?
                </div>
            </div>

<pre><code>// 기존 - 같은 로직인데 오버로딩 3개
void processPacket(char* data, size_t size);           // 포인터 + 크기
void processPacket(std::vector&lt;char&gt;& buffer);         // 벡터
void processPacket(std::array&lt;char, 1024&gt;& buffer);    // 배열</code></pre>

            <div class="thinking-box">
                <div class="t-label">왜 이렇게 여러 개?</div>
                <p>서버에서 패킷 데이터가 들어오는 경로가 다양하기 때문!</p>
                <ul>
                    <li>소켓에서 직접 받은 경우 (C 스타일 포인터)</li>
                    <li>이미 vector로 관리하는 경우</li>
                    <li>고정 크기 array 사용하는 경우</li>
                </ul>
            </div>

            <div class="answer-box">
                <div class="a-label">std::span으로 통합!</div>
<pre><code>// 하나로 다 받음
void processPacket(std::span&lt;char&gt; buffer);

char arr[100];
std::vector&lt;char&gt; vec(100);
std::array&lt;char, 100&gt; stdArr;

processPacket(arr);      // OK
processPacket(vec);      // OK
processPacket(stdArr);   // OK</code></pre>
            </div>

            <div class="question-box">
                <div class="q-label">추가 질문</div>
                <div class="question">
                    span이 어떻게 이걸 가능하게 하는지 원리가 연결이 안 돼.
                </div>
            </div>

            <div class="answer-box">
                <div class="a-label">핵심: 포인터 + 크기</div>
                <p>vector, array, C배열 다 내부는 <strong>"시작 주소 + 크기"</strong>로 표현 가능!</p>
            </div>

<pre><code>// span 내부 구조 (대략)
template&lt;typename T&gt;
class span {
    T* ptr;        // 시작 주소
    size_t size;   // 크기
};

// 각 타입에서 span으로 변환
std::vector&lt;char&gt; vec(100);
std::span&lt;char&gt; s1 = vec;
// s1.ptr  = vec.data()
// s1.size = vec.size()</code></pre>

            <div class="diagram">vector:  [ptr]──→ [■■■■■■■■■■] 메모리
                  ↑
span:    [ptr, size=100] ──┘

array:   [■■■■■■■■■■] 메모리
          ↑
span:    [ptr, size=100] ──┘

span은 원본을 "가리키기만" 해. 복사 안 함.</div>

            <div class="insight-box">
                <h4>요약</h4>
                <ol>
                    <li>vector, array, C배열 다 "연속 메모리"</li>
                    <li>span은 {포인터, 크기}만 저장</li>
                    <li>각 타입에서 span으로 자동 변환 가능</li>
                    <li>함수는 span만 받으면 원본 타입 몰라도 됨</li>
                </ol>
            </div>
        </section>

        <!-- 4. Three-way comparison -->
        <section class="section">
            <h2><span class="step-number">4</span>&lt;=&gt; 우주선 연산자</h2>

            <div class="question-box">
                <div class="q-label">질문</div>
                <div class="question">
                    클래스에 비교 연산자 만들어본 적 있어? 6개나 만들어야 해서 귀찮지 않았어?
                </div>
            </div>

<pre><code>struct Player {
    int level;
    int exp;
};

// 기존 - 6개 다 만들어야 했음
bool operator==(const Player& a, const Player& b);
bool operator!=(const Player& a, const Player& b);
bool operator&lt;(const Player& a, const Player& b);
bool operator&lt;=(const Player& a, const Player& b);
bool operator&gt;(const Player& a, const Player& b);
bool operator&gt;=(const Player& a, const Player& b);</code></pre>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p>편하긴 하겠다. 근데 규칙이 있어야 할 것 같은데.</p>
            </div>

            <div class="answer-box">
                <div class="a-label">하나로 끝!</div>
<pre><code>struct Player {
    int level;
    int exp;

    auto operator&lt;=&gt;(const Player&) const = default;  // 이거 하나로!
};

Player a{10, 500};
Player b{10, 300};

a == b;   // OK
a != b;   // OK
a &lt; b;    // OK
a &lt;= b;   // OK
a &gt; b;    // OK
a &gt;= b;   // OK</code></pre>
            </div>

            <div class="insight-box">
                <h4>규칙 (= default일 때)</h4>
                <p>멤버 변수를 <strong>선언 순서대로</strong> 비교</p>
                <p><code>Player{10, 500} &lt;=&gt; Player{10, 300}</code></p>
                <ol>
                    <li>level 비교: 10 vs 10 → 같음, 다음으로</li>
                    <li>exp 비교: 500 vs 300 → a가 큼</li>
                    <li>결과: a > b</li>
                </ol>
            </div>

            <div class="question-box">
                <div class="q-label">추가 질문</div>
                <div class="question">
                    정수 타입이어야 한다거나 하는 제약조건이 있지 않을까?
                </div>
            </div>

            <div class="answer-box">
                <div class="a-label">멤버들도 &lt;=&gt; 가능해야!</div>
<pre><code>struct Player {
    int level;              // &lt;=&gt; 가능 ✓
    std::string name;       // &lt;=&gt; 가능 ✓
    auto operator&lt;=&gt;(const Player&) const = default;  // OK
};

struct Enemy {
    int hp;
    SomeWeirdClass data;    // &lt;=&gt; 없는 타입 ✗
    auto operator&lt;=&gt;(const Enemy&) const = default;  // 컴파일 에러!
};</code></pre>
            </div>
        </section>

        <!-- 5. std::format -->
        <section class="section">
            <h2><span class="step-number">5</span>std::format - 포맷 문자열</h2>

<pre><code>// 기존 방식들
std::cout &lt;&lt; "Player " &lt;&lt; name &lt;&lt; " (Lv." &lt;&lt; level &lt;&lt; ") HP: " &lt;&lt; hp;
sprintf(buf, "Player %s (Lv.%d) HP: %d", name.c_str(), level, hp);

// C++20 std::format
std::string msg = std::format("Player {} (Lv.{}) HP: {}/{}", name, level, hp, maxHp);

// 포맷 지정
std::format("{:.2f}", 3.14159);     // "3.14" (소수점 2자리)
std::format("{:08d}", 42);          // "00000042" (8자리, 0채움)
std::format("{:&gt;10}", "hi");        // "        hi" (오른쪽 정렬)</code></pre>

            <div class="insight-box">
                <h4>현실</h4>
                <p>타입 안전하고 읽기 쉬운 장점이 있지만, 기존 코드베이스들이 printf나 자체 로깅 라이브러리 쓰고 있어서 아직 많이 안 쓰임.</p>
            </div>
        </section>

        <!-- 6. Ranges -->
        <section class="section">
            <h2><span class="step-number">6</span>Ranges - 파이프라인</h2>

<pre><code>// 기존 - for문으로 필터링 + 변환
std::vector&lt;Player&gt; players;
std::vector&lt;std::string&gt; names;
for (const auto& p : players) {
    if (p.level &gt;= 10) {
        names.push_back(p.name);
    }
}

// C++20 Ranges - 파이프로 체이닝
auto names = players
    | std::views::filter([](const Player& p) { return p.level &gt;= 10; })
    | std::views::transform([](const Player& p) { return p.name; });</code></pre>

            <div class="insight-box red">
                <h4>현실</h4>
                <p>함수형 프로그래밍 좋아하는 사람들은 좋아함. 근데 서버 코드에서? 기존 for문이 더 직관적인 경우 많음. 컴파일 시간도 늘어나고 디버깅도 어려움.</p>
                <p><strong>결론: 알아두면 좋지만 필수는 아님.</strong></p>
            </div>
        </section>

        <!-- 핵심 정리 -->
        <section class="section">
            <h2>C++20 핵심 정리</h2>

            <table>
                <tr>
                    <th>기능</th>
                    <th>핵심</th>
                    <th>실무 활용도</th>
                </tr>
                <tr>
                    <td>Concepts</td>
                    <td>템플릿 제약조건</td>
                    <td>높음</td>
                </tr>
                <tr>
                    <td>Coroutines</td>
                    <td>비동기를 동기처럼</td>
                    <td>높음 (라이브러리 필요)</td>
                </tr>
                <tr>
                    <td>std::span</td>
                    <td>연속 메모리 통합 뷰</td>
                    <td>높음</td>
                </tr>
                <tr>
                    <td>&lt;=&gt;</td>
                    <td>비교 연산자 자동 생성</td>
                    <td>중간</td>
                </tr>
                <tr>
                    <td>std::format</td>
                    <td>타입 안전 포맷팅</td>
                    <td>낮음</td>
                </tr>
                <tr>
                    <td>Ranges</td>
                    <td>파이프라인 처리</td>
                    <td>낮음</td>
                </tr>
            </table>
        </section>

        <footer class="footer">
            <p>MSH Portfolio - Server Developer</p>
        </footer>
    </div>
</body>
</html>
