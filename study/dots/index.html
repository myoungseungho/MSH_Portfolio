<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unity DOTS - MSH Portfolio</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.9;
        }
        .container { max-width: 800px; margin: 0 auto; padding: 60px 20px; }
        .back-link {
            display: inline-block;
            margin-bottom: 24px;
            color: #666;
            text-decoration: none;
        }
        .back-link:hover { color: #111; }
        .header { margin-bottom: 48px; }
        .header h1 { font-size: 2rem; font-weight: 700; color: #111; margin-bottom: 12px; }
        .header p { color: #666; font-size: 1.1rem; }

        /* 대화 스타일 */
        .conversation {
            background: white;
            border-radius: 16px;
            padding: 32px;
            margin: 32px 0;
            border: 1px solid #e0e0e0;
        }
        .conversation h2 {
            font-size: 1.3rem;
            color: #1a237e;
            margin-bottom: 24px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e8eaf6;
        }

        .chat { margin-bottom: 20px; }
        .q {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 16px 20px;
            margin: 16px 0;
            border-radius: 0 12px 12px 0;
            font-weight: 500;
        }
        .q::before {
            content: "Q. ";
            color: #e65100;
            font-weight: 700;
        }
        .a {
            padding: 8px 0 8px 20px;
            border-left: 4px solid #e0e0e0;
            margin: 12px 0;
        }
        .a p { margin-bottom: 12px; }
        .a p:last-child { margin-bottom: 0; }

        .highlight {
            background: #e3f2fd;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #1565c0;
        }
        .key-point {
            background: #c8e6c9;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #2e7d32;
        }
        .warning {
            background: #ffcdd2;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #c62828;
        }

        /* GIF 섹션 */
        .visual-section {
            background: #f5f5f5;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .visual-section h4 {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 12px;
        }
        .step-gif {
            width: 100%;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        .gif-caption {
            font-size: 0.85rem;
            color: #666;
            margin-top: 8px;
            text-align: center;
        }

        /* 코드 블록 */
        .code-block {
            background: #263238;
            border-radius: 8px;
            padding: 16px 20px;
            margin: 16px 0;
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
            color: #eceff1;
            overflow-x: auto;
            line-height: 1.6;
        }

        /* 비교 테이블 */
        .compare-table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            font-size: 0.9rem;
        }
        .compare-table th, .compare-table td {
            padding: 12px;
            border: 1px solid #e0e0e0;
            text-align: left;
        }
        .compare-table th {
            background: #f5f5f5;
            font-weight: 600;
        }

        /* 핵심 정리 박스 */
        .summary-box {
            background: linear-gradient(135deg, #1a237e 0%, #0d47a1 100%);
            border-radius: 16px;
            padding: 32px;
            color: white;
            margin: 32px 0;
        }
        .summary-box h3 {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        .summary-box ul {
            list-style: none;
        }
        .summary-box li {
            padding: 8px 0;
            padding-left: 24px;
            position: relative;
        }
        .summary-box li::before {
            content: "→";
            position: absolute;
            left: 0;
            color: #90caf9;
        }

        .divider {
            height: 1px;
            background: #e0e0e0;
            margin: 32px 0;
        }

        .nav-links {
            display: flex;
            justify-content: space-between;
            margin-top: 60px;
            padding-top: 24px;
            border-top: 1px solid #e0e0e0;
        }
        .nav-links a {
            color: #1a237e;
            text-decoration: none;
        }
        .nav-links a:hover { text-decoration: underline; }

        /* FPS 강조 */
        .fps-good { color: #2e7d32; font-weight: 700; }
        .fps-bad { color: #c62828; font-weight: 700; }
    </style>
</head>
<body>
    <div class="container">
        <a href="../../" class="back-link">← 메인으로</a>

        <header class="header">
            <h1>Unity DOTS</h1>
            <p>Data-Oriented Technology Stack - 수만 개 오브젝트를 60fps로</p>
        </header>

        <!-- Part 1: 기존 방식의 문제 -->
        <div class="conversation">
            <h2>Part 1. 기존 방식(MonoBehaviour)의 한계</h2>

            <div class="chat">
                <div class="q">Unity에서 적 캐릭터 1마리 만들려면 뭘 해?</div>
                <div class="a">
                    <p>게임오브젝트 만들고 스크립트 붙이지.</p>
                </div>
            </div>

            <div class="chat">
                <div class="q">그 스크립트 안에 보통 뭐 넣어?</div>
                <div class="a">
                    <p><span class="highlight">변수</span>랑 <span class="highlight">Update 함수</span>.</p>
                </div>
            </div>

            <div class="chat">
                <div class="q">그럼 적 1000마리 만들면 어떻게 돼?</div>
                <div class="a">
                    <p>게임오브젝트 1000개에 <span class="warning">Update() 1000번 호출</span>되겠지.</p>
                </div>
            </div>

            <div class="chat">
                <div class="q">그게 뭐가 문제야? 당연히 해야 하는 작업 아냐?</div>
                <div class="a">
                    <p>1000마리가 하는 일이 뭔데? <strong>다 똑같은 이동 로직</strong> 아니야?</p>
                    <p><span class="key-point">공통 로직 + 데이터만 다름</span> = 비효율적으로 처리 중</p>
                </div>
            </div>

            <div class="visual-section">
                <h4>시뮬레이션: 바닐라(MonoBehaviour) 50,000개</h4>
                <img src="../../Screenshots/dots/step1.gif" alt="Step 1: Vanilla" class="step-gif">
                <p class="gif-caption">50,000개 오브젝트 → <span class="fps-bad">~20 FPS</span> (버벅거림)</p>
            </div>
        </div>

        <!-- Part 2: ECS 개념 -->
        <div class="conversation">
            <h2>Part 2. ECS가 뭔데?</h2>

            <div class="chat">
                <div class="q">그럼 어떻게 해야 빨라져?</div>
                <div class="a">
                    <p>이렇게 하면?</p>
                    <p>• 로직 1번만 만들고</p>
                    <p>• 데이터 1000개를 <span class="highlight">한 줄로 쭉 넣어서</span> 한 번에 처리</p>
                </div>
            </div>

            <div class="chat">
                <div class="a">
                    <p>이게 <span class="key-point">ECS</span>의 핵심이야:</p>
                    <p>• <strong>E</strong>ntity = 그냥 ID (껍데기)</p>
                    <p>• <strong>C</strong>omponent = 데이터만 (변수)</p>
                    <p>• <strong>S</strong>ystem = 로직만 (함수, 1번만 존재)</p>
                </div>
            </div>

            <div class="code-block">
기존 MonoBehaviour:
→ 오브젝트 1000개 × Update() 1000번 호출

ECS:
→ System 1개가 데이터 1000개 쭉 순회
            </div>

            <div class="chat">
                <div class="q">잠깐, 기존에도 로직은 클래스 하나라서 코드 자체는 하나였잖아. 왜 ECS가 더 빨라?</div>
                <div class="a">
                    <p>핵심은 <span class="highlight">메모리 배치</span>야.</p>
                </div>
            </div>
        </div>

        <!-- Part 3: 캐시 히트 -->
        <div class="conversation">
            <h2>Part 3. 진짜 빨라지는 이유 - 캐시 히트</h2>

            <div class="code-block">
기존 (MonoBehaviour):
적A 데이터 → 메모리 100번지
적B 데이터 → 메모리 9999번지
적C 데이터 → 메모리 50번지
(힙에 흩어져 있음)

ECS:
적A 데이터 → 메모리 100번지
적B 데이터 → 메모리 101번지
적C 데이터 → 메모리 102번지
(연속으로 붙어 있음)
            </div>

            <div class="chat">
                <div class="q">그게 왜 중요해?</div>
                <div class="a">
                    <p>CPU는 <span class="key-point">연속된 메모리</span>를 읽을 때 10~100배 빠름. (캐시 히트)</p>
                    <p>흩어져 있으면 매번 "어디있지?" 찾아다님. (캐시 미스)</p>
                </div>
            </div>

            <div class="chat">
                <div class="q">아, 그러니까 힙에 여러 군데 흩뿌려져 있어서 CPU가 for문 돌릴 때 캐시 미스가 났다는 거지?</div>
                <div class="a">
                    <p><strong>정확해.</strong></p>
                    <p>• 로직(코드 영역) → 어차피 1개</p>
                    <p>• 데이터(힙) → 흩어져 있어서 <span class="warning">데이터 버스에서 캐시 미스</span></p>
                    <p>ECS는 같은 타입 Component를 <span class="key-point">연속 메모리 블록(Chunk)</span>에 몰아넣어서 캐시 히트율 극대화.</p>
                </div>
            </div>
        </div>

        <!-- Part 4: DOTS = ECS + Jobs + Burst -->
        <div class="conversation">
            <h2>Part 4. ECS만으로 끝? DOTS는 뭐야?</h2>

            <div class="chat">
                <div class="q">ECS랑 DOTS랑 뭔 차이야?</div>
                <div class="a">
                    <p><span class="highlight">ECS</span> = 패턴 이름 (Entity-Component-System)</p>
                    <p><span class="highlight">DOTS</span> = Unity가 만든 기술 묶음 (Data-Oriented Technology Stack)</p>
                </div>
            </div>

            <div class="chat">
                <div class="a">
                    <p><strong>DOTS 안에 3개 들어있어:</strong></p>
                    <p>1. <span class="highlight">Entities</span> - ECS 구현체</p>
                    <p>2. <span class="highlight">Jobs</span> - 멀티스레딩 (코어 여러 개 활용)</p>
                    <p>3. <span class="highlight">Burst</span> - C# → 네이티브 코드로 컴파일 (C++ 급 속도)</p>
                </div>
            </div>

            <table class="compare-table">
                <tr>
                    <th>조합</th>
                    <th>성능 향상</th>
                </tr>
                <tr>
                    <td>ECS만</td>
                    <td>2~5배 (캐시 히트)</td>
                </tr>
                <tr>
                    <td>ECS + Burst</td>
                    <td>10~50배</td>
                </tr>
                <tr>
                    <td>ECS + Burst + Jobs</td>
                    <td>100배+</td>
                </tr>
            </table>
        </div>

        <!-- Part 5: Jobs -->
        <div class="conversation">
            <h2>Part 5. Jobs - 놀고 있는 코어 일 시키기</h2>

            <div class="chat">
                <div class="q">컴퓨터 CPU 코어 몇 개야?</div>
                <div class="a">
                    <p>요즘은 보통 8개.</p>
                </div>
            </div>

            <div class="chat">
                <div class="q">기존 Unity Update()는 그 중 몇 개 써?</div>
                <div class="a">
                    <p><span class="warning">1개.</span> 메인스레드만 씀.</p>
                </div>
            </div>

            <div class="chat">
                <div class="q">나머지 7개는?</div>
                <div class="a">
                    <p><strong>놀아.</strong></p>
                    <p><span class="key-point">Jobs = 그 7개도 일 시키는 거.</span></p>
                    <p>적 50,000마리 → 8코어가 6,250마리씩 나눠서 동시에 처리.</p>
                </div>
            </div>
        </div>

        <!-- Part 6: Burst -->
        <div class="conversation">
            <h2>Part 6. Burst - C#을 C++ 급으로</h2>

            <div class="chat">
                <div class="q">C# 코드 짜면 바로 CPU가 실행해?</div>
                <div class="a">
                    <p>아니. C#은 이렇게 돌아가:</p>
                    <p>C# → IL(중간코드) → <span class="warning">런타임에 JIT가 기계어로 변환</span></p>
                    <p>그래서 C++보다 느려. 매번 변환 오버헤드 + JIT가 대충 변환함.</p>
                </div>
            </div>

            <div class="chat">
                <div class="q">Burst는 뭘 해주는 건데?</div>
                <div class="a">
                    <p><span class="key-point">Burst = 미리 빡세게 기계어로 컴파일해놓는 거.</span></p>
                    <p>JIT 건너뛰고, C++ 급으로 최적화된 네이티브 코드 뽑아냄.</p>
                </div>
            </div>
        </div>

        <!-- Part 7: 실제 비교 -->
        <div class="conversation">
            <h2>Part 7. 실제 성능 비교</h2>

            <div class="chat">
                <div class="a">
                    <p>50,000개 오브젝트 이동 기준:</p>
                </div>
            </div>

            <div class="visual-section">
                <h4>Step 1: 바닐라 (MonoBehaviour)</h4>
                <img src="../../Screenshots/dots/step1.gif" alt="Vanilla" class="step-gif">
                <p class="gif-caption"><span class="fps-bad">~20 FPS</span> - Update() 50,000번 호출</p>
            </div>

            <div class="visual-section">
                <h4>Step 2: DOTS (ECS + Burst)</h4>
                <img src="../../Screenshots/dots/step2.gif" alt="DOTS Burst" class="step-gif">
                <p class="gif-caption"><span class="fps-good">~200+ FPS</span> - 연속 메모리 + 네이티브 컴파일</p>
            </div>

            <div class="visual-section">
                <h4>Step 3: DOTS (No Burst) - Burst 끈 상태</h4>
                <img src="../../Screenshots/dots/step3.gif" alt="DOTS No Burst" class="step-gif">
                <p class="gif-caption">Burst 없으면 성능 하락 → Burst의 기여도 확인</p>
            </div>

            <div class="visual-section">
                <h4>Step 4: DOTS (Jobs Parallel) - 멀티코어 활용</h4>
                <img src="../../Screenshots/dots/step4.gif" alt="DOTS Jobs" class="step-gif">
                <p class="gif-caption">8코어 병렬 처리 → 추가 성능 향상</p>
            </div>

            <table class="compare-table">
                <tr>
                    <th>모드</th>
                    <th>FPS (50,000개)</th>
                    <th>특징</th>
                </tr>
                <tr>
                    <td>바닐라</td>
                    <td class="fps-bad">~20</td>
                    <td>Update() 개별 호출, 캐시 미스</td>
                </tr>
                <tr>
                    <td>DOTS (Burst)</td>
                    <td class="fps-good">~200+</td>
                    <td>연속 메모리 + 네이티브 컴파일</td>
                </tr>
                <tr>
                    <td>DOTS (No Burst)</td>
                    <td>~60~80</td>
                    <td>ECS만, Burst 없음</td>
                </tr>
                <tr>
                    <td>DOTS (Jobs)</td>
                    <td class="fps-good">~250+</td>
                    <td>멀티코어 병렬 처리</td>
                </tr>
            </table>
        </div>

        <!-- Part 8: 코드 비교 -->
        <div class="conversation">
            <h2>Part 8. 코드는 어떻게 다를까?</h2>

            <div class="chat">
                <div class="a">
                    <p><strong>바닐라 (MonoBehaviour):</strong></p>
                </div>
            </div>

            <div class="code-block">
public class Enemy : MonoBehaviour
{
    public float speed = 5f;
    public Vector3 direction;

    void Update()  // 오브젝트마다 호출됨
    {
        transform.position += direction * speed * Time.deltaTime;
    }
}
            </div>

            <div class="chat">
                <div class="a">
                    <p><strong>DOTS (ECS):</strong></p>
                </div>
            </div>

            <div class="code-block">
// Component - 데이터만
public struct EnemyData : IComponentData
{
    public float speed;
    public float3 direction;
}

// System - 로직만, 1번만 존재
[BurstCompile]
public partial struct EnemyMovementSystem : ISystem
{
    public void OnUpdate(ref SystemState state)
    {
        float dt = SystemAPI.Time.DeltaTime;

        // 모든 Enemy 데이터를 쭉 순회
        foreach (var (transform, enemy) in
            SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRW&lt;EnemyData&gt;&gt;())
        {
            transform.ValueRW.Position +=
                enemy.ValueRO.direction * enemy.ValueRO.speed * dt;
        }
    }
}
            </div>

            <div class="chat">
                <div class="a">
                    <p><strong>핵심 차이:</strong></p>
                    <p>• 바닐라: 데이터 + 로직이 한 클래스에 묶임</p>
                    <p>• ECS: <span class="key-point">데이터(Component)와 로직(System) 분리</span></p>
                </div>
            </div>
        </div>

        <!-- 전체 정리 -->
        <div class="summary-box">
            <h3>전체 정리</h3>
            <ul>
                <li><strong>ECS</strong> = Entity(ID) + Component(데이터) + System(로직) 분리</li>
                <li><strong>캐시 히트</strong> = 연속 메모리 배치로 CPU가 빠르게 읽음</li>
                <li><strong>Jobs</strong> = 놀고 있는 코어들도 일 시킴 (병렬 처리)</li>
                <li><strong>Burst</strong> = C# → 네이티브 코드로 미리 컴파일</li>
                <li><strong>DOTS</strong> = ECS + Jobs + Burst 합친 Unity 기술 스택</li>
                <li><strong>결과</strong> = 50,000개 기준 20fps → 200+fps (10배↑)</li>
            </ul>
        </div>

        <div class="nav-links">
            <a href="../category-gpu/">← GPU</a>
            <a href="../../">메인으로 →</a>
        </div>
    </div>
</body>
</html>
