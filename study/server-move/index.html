<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>서버 이동 시스템 - MSH Portfolio</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.8;
        }
        .container { max-width: 900px; margin: 0 auto; padding: 60px 20px; }
        .back-link {
            display: inline-block;
            margin-bottom: 24px;
            color: #666;
            text-decoration: none;
        }
        .back-link:hover { color: #111; }
        .header { margin-bottom: 40px; }
        .header h1 { font-size: 2rem; font-weight: 700; color: #111; margin-bottom: 8px; }
        .header p { color: #666; }
        .section {
            background: white;
            border-radius: 16px;
            padding: 32px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            border: 1px solid #eee;
        }
        .section h2 {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 20px;
            color: #111;
            padding-bottom: 12px;
            border-bottom: 2px solid #9C27B0;
        }
        .section h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 24px 0 12px 0;
            color: #333;
        }
        p {
            margin-bottom: 16px;
            color: #444;
        }
        .question {
            background: #f3e5f5;
            padding: 16px 20px;
            border-radius: 8px;
            margin: 16px 0;
            border-left: 4px solid #9C27B0;
        }
        .answer {
            background: #f5f5f5;
            padding: 16px 20px;
            border-radius: 8px;
            margin: 16px 0;
            border-left: 4px solid #4CAF50;
        }
        .flow-diagram {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 24px;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        .highlight {
            background: #f3e5f5;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }
        .warning {
            background: #fff3e0;
            padding: 16px 20px;
            border-radius: 8px;
            margin: 16px 0;
            border-left: 4px solid #FF9800;
        }
        .danger {
            background: #ffebee;
            padding: 16px 20px;
            border-radius: 8px;
            margin: 16px 0;
            border-left: 4px solid #f44336;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #e0e0e0;
            padding: 12px;
            text-align: left;
        }
        th {
            background: #f5f5f5;
            font-weight: 600;
        }
        ul, ol {
            margin: 16px 0;
            padding-left: 24px;
        }
        li {
            margin-bottom: 8px;
        }
        .comparison-box {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin: 20px 0;
        }
        .comparison-item {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        .comparison-item h4 {
            font-size: 1rem;
            margin-bottom: 12px;
            color: #111;
        }
        .comparison-item.good {
            border-left: 4px solid #4CAF50;
        }
        .comparison-item.bad {
            border-left: 4px solid #f44336;
        }
        .feature-list {
            background: #fafafa;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #e0e0e0;
        }
        .feature-list h4 {
            color: #9C27B0;
            margin-bottom: 12px;
        }
        @media (max-width: 600px) {
            .comparison-box {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="../category-web/" class="back-link">← 웹서버 (Node.js)</a>

        <header class="header">
            <h1>서버 이동 시스템</h1>
            <p>캐릭터를 다른 게임 서버로 이동시키는 중앙 처리 시스템</p>
        </header>

        <!-- 1. 서버 이동이란? -->
        <section class="section">
            <h2>1. 서버 이동이란?</h2>

            <div class="question">
                <strong>Q:</strong> 게임에서 "서버 이동"은 왜 필요할까?
            </div>

            <div class="answer">
                <strong>A:</strong> 유저가 다른 서버에 있는 친구와 함께 플레이하거나, 인구가 적은 서버에서 활성화된 서버로 옮기고 싶을 때 필요하다.
            </div>

            <p>
                게임 서버는 보통 <span class="highlight">서버별로 DB가 분리</span>되어 있다.
                11번 서버의 캐릭터 데이터는 GameDB_11에, 12번 서버는 GameDB_12에 저장된다.
            </p>

            <div class="flow-diagram">
[게임서버 11번] → [GameDB_11] - 캐릭터A 데이터
[게임서버 12번] → [GameDB_12] - 캐릭터B 데이터
[게임서버 13번] → [GameDB_13] - 캐릭터C 데이터
...

각 게임서버는 자신의 DB만 접근 가능
            </div>
        </section>

        <!-- 2. 왜 중앙 서버가 필요한가? -->
        <section class="section">
            <h2>2. 왜 중앙 서버 이동 서버가 필요한가?</h2>

            <div class="question">
                <strong>Q:</strong> 게임서버가 직접 캐릭터 이동을 처리하면 안 될까?
            </div>

            <div class="comparison-box">
                <div class="comparison-item bad">
                    <h4>게임서버가 직접 처리</h4>
                    <p>11번 서버 → 12번, 13번, 14번... 모든 DB 연결 필요</p>
                    <p>서버 20개면 × 20개 DB 연결 = 관리 지옥</p>
                    <p>새 서버 추가 시 모든 게임서버 수정 필요</p>
                </div>
                <div class="comparison-item good">
                    <h4>중앙 서버 이동 서버</h4>
                    <p>1대가 모든 DB 연결 보유</p>
                    <p>게임서버는 이동 요청만 보내면 끝</p>
                    <p>새 서버 추가해도 이 서버만 수정</p>
                </div>
            </div>

            <div class="flow-diagram">
[게임서버 11] ──┐
[게임서버 12] ──┼──TCP 소켓──→ [서버이동서버] ──→ [모든 GameDB]
[게임서버 13] ──┘                    │
                                    ├── GameDB_11
                                    ├── GameDB_12
                                    ├── GameDB_13
                                    ├── TradeDB
                                    ├── AccountDB
                                    └── MongoDB (로그)
            </div>

            <div class="answer">
                <strong>핵심:</strong> 여러 DB에 동시 접근해야 하는 작업은 중앙에서 처리하는 게 효율적이다.
            </div>
        </section>

        <!-- 3. 서버 이동 서버의 기능들 -->
        <section class="section">
            <h2>3. 서버 이동 서버의 기능</h2>

            <div class="feature-list">
                <h4>기능 1: 서버 이동 가능 여부 조회</h4>
                <p>"이 캐릭터가 어느 서버로 이동 가능해?"</p>
                <ul>
                    <li>각 서버별 캐릭터 슬롯이 남았는지</li>
                    <li>거래소/우편함이 비었는지</li>
                    <li>돈을 합치면 오버플로우가 나는지</li>
                </ul>
            </div>

            <div class="feature-list">
                <h4>기능 2: 서버 이동 직전 최종 검사</h4>
                <p>"진짜 이동해도 돼?"</p>
                <ul>
                    <li>거래소에 물건 있으면 → 거부</li>
                    <li>우편함에 아이템 있으면 → 거부</li>
                    <li>공성전 시간이면 → 거부</li>
                    <li>대상 서버 유입 인원 초과면 → 거부</li>
                </ul>
            </div>

            <div class="feature-list">
                <h4>기능 3: 실제 캐릭터 복사</h4>
                <p>"OK, 이제 진짜 옮겨"</p>
                <ul>
                    <li>계정 잠금</li>
                    <li>GameDB 11번 → GameDB 12번 캐릭터 데이터 복사</li>
                    <li>성공하면 잠금 해제</li>
                    <li>실패하면 잠금 유지 (수동 처리)</li>
                    <li>MongoDB에 로그 기록</li>
                </ul>
            </div>

            <div class="feature-list">
                <h4>기능 4: 서버 이동 탭 활성화 여부</h4>
                <p>게임서버가 1분마다 물어봄: "지금 서버 이동 UI 보여줘도 돼?"</p>
                <ul>
                    <li>공성전 시간이면 비활성화</li>
                    <li>이동 가능한 서버 없으면 비활성화</li>
                </ul>
            </div>
        </section>

        <!-- 4. 계정 잠금의 중요성 -->
        <section class="section">
            <h2>4. 왜 복사 전에 계정을 잠글까?</h2>

            <div class="question">
                <strong>Q:</strong> 잠금 없이 바로 복사하면 어떤 문제가 생길까?
            </div>

            <div class="danger">
                <strong>문제 상황:</strong><br>
                복사 시작 → 유저가 게임 계속 플레이 → 보스 잡고 전설템 획득 → 복사 완료<br><br>
                결과: 새 서버에 도착하면 <strong>전설템이 없는</strong> 캐릭터가 됨!
            </div>

            <div class="flow-diagram">
안전한 순서:

1. 계정 잠금 (acc_lock_type = 1)
   → 유저 로그인/플레이 불가

2. 캐릭터 데이터 복사 (안전하게)

3. 성공 → 잠금 해제 (acc_lock_type = 0)
   실패 → 잠금 유지 (개발자가 수동 처리)
            </div>

            <div class="warning">
                <strong>실패 시 왜 잠금을 유지할까?</strong><br>
                복사가 중간에 실패하면 대상 서버에 "반쪽짜리 데이터"가 있을 수 있다.
                자동으로 잠금을 풀면 유저가 깨진 캐릭터를 볼 수 있으므로,
                개발자가 확인 후 수동으로 정리해야 한다.
            </div>
        </section>

        <!-- 5. 이동 조건 체크 -->
        <section class="section">
            <h2>5. 서버 이동 조건들</h2>

            <div class="question">
                <strong>Q:</strong> 왜 거래소와 우편함을 비워야 할까?
            </div>

            <table>
                <tr>
                    <th>조건</th>
                    <th>이유</th>
                </tr>
                <tr>
                    <td>거래소 비어있어야 함</td>
                    <td>거래소 DB는 서버별로 분리됨. 물건 등록 상태로 이동하면 구매자가 골드를 줄 곳을 찾지 못함</td>
                </tr>
                <tr>
                    <td>우편함 비어있어야 함</td>
                    <td>우편함 데이터가 GameDB에 있어서, 이동 시 누락될 수 있음</td>
                </tr>
                <tr>
                    <td>공성전 시간 아니어야 함</td>
                    <td>콘텐츠 진행 중 이동하면 참가자 목록, 길드 정보 등이 꼬임</td>
                </tr>
                <tr>
                    <td>대상 서버 슬롯 있어야 함</td>
                    <td>캐릭터 슬롯이 꽉 차면 이동 불가</td>
                </tr>
                <tr>
                    <td>돈 합계 오버플로우 체크</td>
                    <td>두 서버의 골드를 합쳤을 때 최대값을 넘으면 안 됨</td>
                </tr>
            </table>
        </section>

        <!-- 6. TCP 소켓 통신 -->
        <section class="section">
            <h2>6. Node.js인데 웹서버가 아니다?</h2>

            <div class="question">
                <strong>Q:</strong> Node.js로 만들었으면 웹서버 아닌가?
            </div>

            <div class="answer">
                <strong>A:</strong> Node.js는 그냥 "JavaScript 실행 환경"이다. 웹서버도 만들 수 있고, TCP 소켓 서버도 만들 수 있다.
            </div>

            <div class="comparison-box">
                <div class="comparison-item">
                    <h4>웹서버 (HTTP)</h4>
                    <p>Classic_Web</p>
                    <p>클라이언트(앱)가 URL로 요청</p>
                    <p>랭킹, 버전, 결제 등</p>
                    <pre style="margin-top:12px;font-size:0.85rem;">res.json(data);</pre>
                </div>
                <div class="comparison-item">
                    <h4>소켓서버 (TCP)</h4>
                    <p>nodejs_Servermove</p>
                    <p>게임서버가 직접 연결</p>
                    <p>바이너리 패킷 통신</p>
                    <pre style="margin-top:12px;font-size:0.85rem;">server.sendMessage(packet);</pre>
                </div>
            </div>

            <p>
                C++ 게임서버 입장에서 보면, 이 서버는 그냥 <span class="highlight">또 다른 TCP 소켓 서버</span>다.
                Node.js로 만들었을 뿐, 통신 방식은 게임서버끼리 통신하는 것과 똑같다.
            </p>
        </section>

        <!-- 7. C++ 게임서버와 Node.js 연동 -->
        <section class="section">
            <h2>7. C++ 게임서버와 Node.js 연동</h2>

            <div class="question">
                <strong>Q:</strong> C++ 게임서버는 어떻게 Node.js 서버이동서버와 통신할까?
            </div>

            <h3>C++ 게임서버 코드 (Server.cpp)</h3>
            <div class="flow-diagram">
// 게임서버에서 Node.js로 보내는 함수
BOOL CServer::Send_to_DCP_ServerMove(map&lt;wstring, wstring&gt;&amp; strMap)
{
    // map → JSON 변환
    // {"type":"1","fieldunique":"12345","charunique":"54321",...}

    // TCP 소켓으로 Node.js 서버이동서버에 전송
    g_ClientArray[g_ServerArray.Bravo_NodeJS_ServerMove]
        .Write((BYTE*)&amp;sendmsg, packetSize);
}
            </div>

            <h3>호출 위치 (ServerMsgProcess.cpp)</h3>
            <div class="flow-diagram">
case CM_SERVER_MOVE_INFO:   // 클라이언트가 서버이동 요청
{
    map&lt;wstring, wstring&gt; sendmsg;
    sendmsg.insert(pair&lt;wstring, wstring&gt;(L"type", L"1"));
    sendmsg.insert(pair&lt;wstring, wstring&gt;(L"fieldunique", ...));
    sendmsg.insert(pair&lt;wstring, wstring&gt;(L"charunique", ...));
    sendmsg.insert(pair&lt;wstring, wstring&gt;(L"accunique", ...));

    g_Server.Send_to_DCP_ServerMove(sendmsg);  // Node.js로 전송!
}
            </div>

            <div class="answer">
                <strong>핵심:</strong> C++ 게임서버가 map을 JSON으로 변환해서 TCP 소켓으로 Node.js에 전송한다.
            </div>
        </section>

        <!-- 8. 복사되는 테이블들 -->
        <section class="section">
            <h2>8. 복사되는 테이블들 (game_Table.js)</h2>

            <p>
                Node.js 서버가 원본 DB에서 SELECT 후, 대상 DB에 INSERT하는 테이블들:
            </p>

            <table>
                <tr>
                    <th>테이블</th>
                    <th>내용</th>
                </tr>
                <tr>
                    <td>TCharacter</td>
                    <td>캐릭터 기본 정보 (이름, 레벨, 직업 등)</td>
                </tr>
                <tr>
                    <td>TInventory</td>
                    <td>인벤토리 아이템</td>
                </tr>
                <tr>
                    <td>TClearQuest</td>
                    <td>퀘스트 진행/완료 정보</td>
                </tr>
                <tr>
                    <td>Trestore</td>
                    <td>복구 아이템</td>
                </tr>
                <tr>
                    <td>TDungeonList</td>
                    <td>던전 클리어 정보</td>
                </tr>
                <tr>
                    <td>TAccumulate</td>
                    <td>업적 데이터</td>
                </tr>
                <tr>
                    <td>TSinsuList</td>
                    <td>신수 리스트</td>
                </tr>
                <tr>
                    <td>TChannelCommon</td>
                    <td>유물/팔괘석</td>
                </tr>
                <tr>
                    <td>TEventPoint</td>
                    <td>이벤트 포인트</td>
                </tr>
                <tr>
                    <td>TGrowPassReward</td>
                    <td>성장 패스 보상</td>
                </tr>
                <tr>
                    <td>TDoongapList</td>
                    <td>둥갑 리스트</td>
                </tr>
                <tr>
                    <td>TAttendPackage</td>
                    <td>출석 패키지</td>
                </tr>
                <tr>
                    <td>TTitle</td>
                    <td>칭호</td>
                </tr>
                <tr>
                    <td>TMonsterCollectionList</td>
                    <td>몬스터 컬렉션</td>
                </tr>
                <tr>
                    <td colspan="2" style="text-align:center;color:#666;">... 총 30개+ 테이블</td>
                </tr>
            </table>

            <div class="flow-diagram">
복사 흐름:

[GameDB_11] ──SELECT──→ [Node.js 메모리] ──INSERT──→ [GameDB_12]

1. 원본 DB에서 30개+ 테이블 데이터 조회
2. Node.js 메모리에 임시 저장
3. 대상 DB에 순차적으로 삽입
            </div>
        </section>

        <!-- 9. 전체 흐름 -->
        <section class="section">
            <h2>9. 전체 흐름 정리</h2>

            <div class="flow-diagram">
[클라이언트] "서버 이동하고 싶어" (CM_SERVER_MOVE_INFO)
      ↓
[C++ 게임서버] Server.cpp → JSON 패킷 생성 → TCP 전송
      ↓
[Node.js 서버이동서버] 조건 체크:
  - 거래소에 물건 있나? → 있으면 거부
  - 우편함에 뭐 있나? → 있으면 거부
  - 공성전 시간인가? → 맞으면 거부
  - 대상 서버 슬롯 있나? → 없으면 거부
      ↓
조건 통과 → AccountDB에서 계정 잠금
      ↓
game_Table.copy_GAMEDB() 호출:
  - GameDB_11에서 30개+ 테이블 SELECT
  - Node.js 메모리에 임시 저장
  - GameDB_12에 INSERT
      ↓
MongoDB에 서버이동 로그 기록
      ↓
성공 → 잠금 해제 / 실패 → 잠금 유지
      ↓
[C++ 게임서버] ← DSM_SERVER_MOVE 응답 수신
      ↓
[클라이언트] 새 서버로 재접속 안내
            </div>
        </section>

        <!-- 10. 핵심 정리 -->
        <section class="section">
            <h2>10. 핵심 정리</h2>

            <table>
                <tr>
                    <th>개념</th>
                    <th>설명</th>
                    <th>이유</th>
                </tr>
                <tr>
                    <td>중앙 서버 이동 서버</td>
                    <td>모든 DB 접근을 1곳에서 처리</td>
                    <td>게임서버마다 모든 DB 연결하는 것보다 효율적</td>
                </tr>
                <tr>
                    <td>계정 잠금</td>
                    <td>복사 중 플레이 차단</td>
                    <td>데이터 정합성 보장</td>
                </tr>
                <tr>
                    <td>조건 체크</td>
                    <td>거래소/우편함/공성전 등</td>
                    <td>이동 후 데이터 꼬임 방지</td>
                </tr>
                <tr>
                    <td>실패 시 잠금 유지</td>
                    <td>자동 해제 안 함</td>
                    <td>반쪽짜리 데이터 노출 방지</td>
                </tr>
                <tr>
                    <td>TCP 소켓 통신</td>
                    <td>HTTP 대신 직접 연결</td>
                    <td>게임서버와 익숙한 방식으로 통신</td>
                </tr>
            </table>
        </section>
    </div>
</body>
</html>
