<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>메모리 할당 전략 - MSH Portfolio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.8;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 60px 20px;
        }

        .nav {
            margin-bottom: 40px;
        }

        .nav a {
            color: #666;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .nav a:hover {
            color: #333;
        }

        .header {
            margin-bottom: 50px;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 16px;
            color: #111;
        }

        .header-meta {
            display: flex;
            gap: 20px;
            color: #666;
            font-size: 0.9rem;
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 20px 0;
        }

        .tag {
            background: #e8f4fd;
            color: #1976d2;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .section {
            margin-bottom: 50px;
        }

        .section h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #111;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .section h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 30px 0 15px 0;
            color: #333;
        }

        .section p {
            margin-bottom: 16px;
            color: #444;
        }

        /* 대화형 질문-답변 스타일 */
        .question-box {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            border-left: 4px solid #667eea;
            padding: 20px;
            border-radius: 0 12px 12px 0;
            margin: 25px 0;
        }

        .question-box .q-label {
            color: #667eea;
            font-weight: 700;
            font-size: 0.85rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .question-box .q-label::before {
            content: "Q";
            background: #667eea;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .question-box .question {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
        }

        .answer-box {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 20px;
            border-radius: 0 12px 12px 0;
            margin: 20px 0;
        }

        .answer-box .a-label {
            color: #2e7d32;
            font-weight: 700;
            font-size: 0.85rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .answer-box .a-label::before {
            content: "A";
            background: #4caf50;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .insight-box {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin: 20px 0;
        }

        .insight-box h4 {
            color: #e65100;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .insight-box.red {
            background: #ffebee;
            border-left-color: #f44336;
        }

        .insight-box.red h4 {
            color: #c62828;
        }

        .insight-box.green {
            background: #e8f5e9;
            border-left-color: #4caf50;
        }

        .insight-box.green h4 {
            color: #2e7d32;
        }

        .insight-box.blue {
            background: #e3f2fd;
            border-left-color: #2196f3;
        }

        .insight-box.blue h4 {
            color: #1565c0;
        }

        .diagram {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            overflow-x: auto;
            margin: 20px 0;
            line-height: 1.5;
            white-space: pre;
        }

        .diagram-light {
            background: white;
            border: 1px solid #e0e0e0;
            color: #333;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            overflow-x: auto;
            margin: 20px 0;
            line-height: 1.5;
            white-space: pre;
        }

        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }

        pre code {
            background: none;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }

        th, td {
            padding: 14px 16px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background: #f8f8f8;
            font-weight: 600;
            color: #333;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            font-weight: 700;
            font-size: 0.9rem;
            margin-right: 10px;
        }

        .compare-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        @media (max-width: 600px) {
            .compare-grid {
                grid-template-columns: 1fr;
            }
        }

        .compare-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            border: 1px solid #eee;
        }

        .compare-card h4 {
            font-size: 1rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .compare-card.bad {
            border-top: 3px solid #f44336;
        }

        .compare-card.bad h4 {
            color: #d32f2f;
        }

        .compare-card.good {
            border-top: 3px solid #4caf50;
        }

        .compare-card.good h4 {
            color: #388e3c;
        }

        .footer {
            text-align: center;
            padding: 40px 0;
            color: #999;
            font-size: 0.9rem;
            border-top: 1px solid #e0e0e0;
            margin-top: 60px;
        }

        ul, ol {
            margin: 16px 0;
            padding-left: 24px;
        }

        li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav">
            <a href="../../">&larr; 돌아가기</a>
        </nav>

        <header class="header">
            <h1>메모리 할당 전략</h1>
            <div class="header-meta">
                <span>Operating System</span>
                <span>Memory Management</span>
            </div>
            <div class="tags">
                <span class="tag">Fragmentation</span>
                <span class="tag">Object Pool</span>
                <span class="tag">Memory Pool</span>
                <span class="tag">Game Server</span>
            </div>
        </header>

        <!-- 개요 -->
        <section class="section">
            <h2>개요</h2>
            <p>
                게임 서버에서 수천 개의 객체가 생성/삭제를 반복하면 메모리가 조각나서 성능이 떨어진다.
                이 문서는 <strong>질문을 던지고 답을 찾아가는 방식</strong>으로 메모리 단편화의 원리와 해결책을 탐구한다.
            </p>
        </section>

        <!-- 첫 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">1</span>new/delete를 반복하면?</h2>

            <div class="question-box">
                <div class="q-label">첫 번째 질문</div>
                <div class="question">
                    게임 서버에서 몬스터가 스폰될 때마다 new Monster()를 호출한다. 1만 마리가 스폰되고 죽기를 반복하면 메모리에서 어떤 문제가 생길까?
                </div>
            </div>

<pre><code>// 몬스터 스폰 시
Monster* pMon = new Monster();  // 64바이트

// 몬스터 사망 시
delete pMon;</code></pre>

            <div class="answer-box">
                <div class="a-label">외부 단편화 (External Fragmentation)</div>
                <p>빈 공간은 충분한데, 조각조각 흩어져서 큰 요청을 못 받는다!</p>
            </div>

            <div class="diagram">[메모리 상태 - 외부 단편화]

  사용중    빈공간    사용중    빈공간    사용중    빈공간
├────────┤░░░░░░░░├────────┤░░░░░░├────────┤░░░░░░░░┤
   64B       32B      64B      24B     64B       40B

총 빈 공간: 32 + 24 + 40 = 96B
But 연속 64B 요청? → 실패! (조각나서 못 줌)</div>
        </section>

        <!-- 두 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">2</span>빈 공간 중 어디에 배치?</h2>

            <div class="question-box">
                <div class="q-label">두 번째 질문</div>
                <div class="question">
                    빈 공간이 여러 개 있을 때, 새 요청을 어디에 배치해야 단편화를 줄일 수 있을까?
                </div>
            </div>

            <div class="diagram">[빈 공간 리스트]
Hole A: 100B (주소 0x1000)
Hole B: 500B (주소 0x2000)
Hole C: 200B (주소 0x3000)
Hole D: 300B (주소 0x4000)

→ 212B 요청이 들어왔다. 어디에?</div>

            <div class="answer-box">
                <div class="a-label">3가지 할당 전략</div>
            </div>

            <table>
                <tr>
                    <th>전략</th>
                    <th>방식</th>
                    <th>212B 배치</th>
                    <th>특징</th>
                </tr>
                <tr>
                    <td><strong>First-fit</strong></td>
                    <td>처음 맞는 곳</td>
                    <td>Hole C (200B) → 부족<br>Hole D (300B) ✅</td>
                    <td>빠름, 성능 괜찮음</td>
                </tr>
                <tr>
                    <td><strong>Best-fit</strong></td>
                    <td>가장 딱 맞는 곳</td>
                    <td>Hole D (300B) ✅<br>남는 조각 88B</td>
                    <td>탐색 느림, 자투리 多</td>
                </tr>
                <tr>
                    <td><strong>Worst-fit</strong></td>
                    <td>가장 큰 곳</td>
                    <td>Hole B (500B)<br>남는 조각 288B</td>
                    <td>큰 공간 빨리 소진</td>
                </tr>
            </table>

            <div class="insight-box">
                <h4>직관: 500B는 아까우니까 300B에 넣자</h4>
                <p>→ 이게 Best-fit 전략! 나중에 큰 요청 올 때를 위해 큰 공간 보존.</p>
            </div>
        </section>

        <!-- 세 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">3</span>Best-fit의 함정?</h2>

            <div class="question-box">
                <div class="q-label">세 번째 질문</div>
                <div class="question">
                    Best-fit이 항상 좋을까? 계속 사용하면 어떤 문제가 생길까?
                </div>
            </div>

            <div class="diagram">[Best-fit 반복 사용 후]

├──사용──┤░12B░├──사용──┤░8B░├──사용──┤░15B░├──사용──┤░6B░┤
          자투리      자투리      자투리      자투리

→ 아주 작은 자투리들이 쌓임
→ 뭘 넣어도 안 들어감 (쓰레기)</div>

            <div class="insight-box red">
                <h4>Best-fit의 역설</h4>
                <p>"아껴 쓰려다 오히려 못 쓰게 됨"</p>
                <p>Worst-fit은 288B 남겨서 다음 요청도 수용 가능!</p>
            </div>

            <div class="diagram-light">[실험 결과 - 일반적으로]

First-fit  ⭐⭐⭐  → 속도 빠름, 성능 괜찮음
Best-fit   ⭐⭐    → 탐색 느림, 자투리 많음
Worst-fit  ⭐      → 큰 공간 빨리 소진</div>
        </section>

        <!-- 네 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">4</span>게임 서버의 해결책?</h2>

            <div class="question-box">
                <div class="q-label">네 번째 질문</div>
                <div class="question">
                    몬스터가 항상 64B로 고정 크기라면, 단편화를 완전히 없앨 방법이 있을까?
                </div>
            </div>

            <div class="answer-box">
                <div class="a-label">오브젝트 풀 (Object Pool)</div>
                <p>미리 64B짜리 방을 쭉 만들어 놓고 재사용!</p>
            </div>

            <div class="diagram">[메모리 풀 방식]

초기화 시 미리 할당:
┌──64B──┬──64B──┬──64B──┬──64B──┬──64B──┬──64B──┐
│ 빈방  │ 빈방  │ 빈방  │ 빈방  │ 빈방  │ 빈방  │
└───────┴───────┴───────┴───────┴───────┴───────┘

몬스터 스폰:
┌──64B──┬──64B──┬──64B──┬──64B──┬──64B──┬──64B──┐
│몬스터A│ 빈방  │몬스터B│ 빈방  │몬스터C│ 빈방  │
└───────┴───────┴───────┴───────┴───────┴───────┘

몬스터 사망 → delete 안 함, 그냥 "빈방" 표시!
┌──64B──┬──64B──┬──64B──┬──64B──┬──64B──┬──64B──┐
│ 빈방  │ 빈방  │몬스터B│ 빈방  │ 빈방  │ 빈방  │
└───────┴───────┴───────┴───────┴───────┴───────┘

→ 외부 단편화 0%!
→ new/delete 오버헤드 0!</div>

            <div class="insight-box green">
                <h4>핵심 아이디어</h4>
                <p>OS에게 메모리 요청/반환하지 않고, 미리 확보한 풀에서 재사용!</p>
            </div>
        </section>

        <!-- 다섯 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">5</span>크기가 다른 객체는?</h2>

            <div class="question-box">
                <div class="q-label">다섯 번째 질문</div>
                <div class="question">
                    64B 풀에 32B 슬라임을 넣으면 32B가 남는다. 이건 무슨 단편화?
                </div>
            </div>

            <div class="diagram">┌────────────64B────────────┐
│ Slime(32B) │ ░░낭비░░░░░ │
└────────────┴──────────────┘
               남는 32B는?</div>

            <div class="answer-box">
                <div class="a-label">내부 단편화 (Internal Fragmentation)</div>
                <p>할당된 블록 "안에서" 공간이 낭비되는 것!</p>
            </div>

            <div class="diagram-light">[외부 vs 내부 단편화]

외부 단편화:  블록 "바깥"에 자투리 흩어짐
├──사용──┤░░░├──사용──┤░░├──사용──┤
          ↑       ↑
        못 쓰는 조각들

내부 단편화:  블록 "안에서" 낭비
┌────────────64B────────────┐
│ Slime(32B) │ ░░낭비░░░░░ │  ← 할당은 됐는데 못 씀
└────────────┴──────────────┘</div>
        </section>

        <!-- 여섯 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">6</span>내부 단편화 해결?</h2>

            <div class="question-box">
                <div class="q-label">여섯 번째 질문</div>
                <div class="question">
                    내부 단편화도 완전히 해결할 수 있을까?
                </div>
            </div>

            <div class="answer-box">
                <div class="a-label">완전 해결 불가능, 최소화만 가능</div>
            </div>

            <div class="diagram-light">[트레이드오프]

내부 단편화 줄이려면 → 딱 맞는 크기로 할당 → 외부 단편화 ↑
외부 단편화 줄이려면 → 고정 크기 블록 사용 → 내부 단편화 ↑

→ 둘 다 0%는 불가능!</div>

            <h3>해결책: 크기별 풀 분리</h3>

            <div class="diagram">[다양한 크기 풀 준비]

32B 풀  ──┬──┬──┬──┬──  → 슬라임용
48B 풀  ──┬──┬──┬──┬──  → 고블린용
64B 풀  ──┬──┬──┬──┬──  → 오크용
128B 풀 ──┬──┬──┬──┬──  → 드래곤용

50B 요청 → 64B 풀에서 (14B 낭비)
30B 요청 → 32B 풀에서 (2B 낭비)

→ 풀 종류 많을수록 내부 단편화 ↓
→ 근데 관리 복잡도 ↑</div>

            <div class="insight-box blue">
                <h4>Slab Allocator</h4>
                <p>리눅스 커널, tcmalloc, jemalloc이 쓰는 방식.</p>
                <p>게임 개발에서는 "오브젝트 풀"이라고 부름 - <strong>같은 개념!</strong></p>
            </div>
        </section>

        <!-- 실전 예시 -->
        <section class="section">
            <h2><span class="step-number">7</span>실전: 총알 시스템</h2>

            <div class="compare-grid">
                <div class="compare-card bad">
                    <h4>❌ new/delete 방식</h4>
<pre><code>void Fire() {
    // OS에게 24B 요청
    Bullet* b = new Bullet();
}

void OnHit() {
    // OS에게 반환
    delete bullet;
}

// 1초에 1000발
// → 1000번 시스템콜</code></pre>
                    <p style="margin-top: 12px; color: #666; font-size: 0.85rem;">
                        → 외부 단편화 심각<br>
                        → 시스템콜 오버헤드<br>
                        → 메모리 할당 실패 가능
                    </p>
                </div>
                <div class="compare-card good">
                    <h4>✅ 오브젝트 풀 방식</h4>
<pre><code>BulletPool g_Pool;

void Fire() {
    // 풀에서 꺼냄 (포인터만)
    Bullet* b = g_Pool.Alloc();
}

void OnHit() {
    // 플래그만 변경
    g_Pool.Free(bullet);
}

// 1초에 1000발
// → 시스템콜 0번</code></pre>
                    <p style="margin-top: 12px; color: #666; font-size: 0.85rem;">
                        → 외부 단편화 0%<br>
                        → 할당 속도 10배↑<br>
                        → 메모리 안정적
                    </p>
                </div>
            </div>
        </section>

        <!-- 최종 정리 -->
        <section class="section">
            <h2>핵심 정리</h2>

            <table>
                <tr>
                    <th>질문</th>
                    <th>답</th>
                </tr>
                <tr>
                    <td>외부 단편화란?</td>
                    <td>빈 공간이 흩어져서 큰 요청 실패</td>
                </tr>
                <tr>
                    <td>내부 단편화란?</td>
                    <td>할당 블록 안에서 공간 낭비</td>
                </tr>
                <tr>
                    <td>First/Best/Worst-fit?</td>
                    <td>빈 공간 선택 전략 (First가 무난)</td>
                </tr>
                <tr>
                    <td>외부 단편화 해결?</td>
                    <td>오브젝트 풀 (고정 크기 재사용)</td>
                </tr>
                <tr>
                    <td>내부 단편화 해결?</td>
                    <td>완전 해결 불가, 크기별 풀로 최소화</td>
                </tr>
                <tr>
                    <td>Slab Allocator?</td>
                    <td>오브젝트 풀과 같은 개념 (이름만 다름)</td>
                </tr>
            </table>

            <div class="insight-box green">
                <h4>게임 서버 실전 결론</h4>
<pre style="background: transparent; padding: 0; margin: 10px 0; color: #2e7d32;"><code>// 객체별로 풀 따로 만들면 내/외부 단편화 둘 다 해결!

CObjectPool&lt;Monster, 1000&gt; g_MonsterPool;  // 몬스터 전용
CObjectPool&lt;Bullet, 5000&gt;  g_BulletPool;   // 총알 전용
CObjectPool&lt;Effect, 2000&gt;  g_EffectPool;   // 이펙트 전용

→ 같은 크기끼리 풀링 = 단편화 0%</code></pre>
            </div>
        </section>

        <footer class="footer">
            <p>MSH Portfolio - Server Developer</p>
        </footer>
    </div>
</body>
</html>
