<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>매치메이킹 시스템 - MSH Portfolio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.8;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 60px 20px;
        }

        .nav {
            margin-bottom: 40px;
        }

        .nav a {
            color: #666;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .nav a:hover {
            color: #333;
        }

        .header {
            margin-bottom: 50px;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 16px;
            color: #111;
        }

        .header-meta {
            display: flex;
            gap: 20px;
            color: #666;
            font-size: 0.9rem;
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 20px 0;
        }

        .tag {
            background: #e8f4fd;
            color: #1976d2;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .section {
            margin-bottom: 50px;
        }

        .section h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #111;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .section h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 30px 0 15px 0;
            color: #333;
        }

        .section p {
            margin-bottom: 16px;
            color: #444;
        }

        /* 대화형 질문-답변 스타일 */
        .question-box {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            border-left: 4px solid #667eea;
            padding: 20px;
            border-radius: 0 12px 12px 0;
            margin: 25px 0;
        }

        .question-box .q-label {
            color: #667eea;
            font-weight: 700;
            font-size: 0.85rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .question-box .q-label::before {
            content: "Q";
            background: #667eea;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .question-box .question {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
        }

        .thinking-box {
            background: #fff8e1;
            border-left: 4px solid #ffb300;
            padding: 20px;
            border-radius: 0 12px 12px 0;
            margin: 20px 0;
        }

        .thinking-box .t-label {
            color: #f57c00;
            font-weight: 700;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .answer-box {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 20px;
            border-radius: 0 12px 12px 0;
            margin: 20px 0;
        }

        .answer-box .a-label {
            color: #2e7d32;
            font-weight: 700;
            font-size: 0.85rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .answer-box .a-label::before {
            content: "A";
            background: #4caf50;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .insight-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin: 20px 0;
        }

        .insight-box h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .insight-box.blue {
            background: #e3f2fd;
            border-left-color: #2196f3;
        }

        .insight-box.blue h4 {
            color: #1565c0;
        }

        .insight-box.green {
            background: #e8f5e9;
            border-left-color: #4caf50;
        }

        .insight-box.green h4 {
            color: #2e7d32;
        }

        .insight-box.red {
            background: #ffebee;
            border-left-color: #f44336;
        }

        .insight-box.red h4 {
            color: #c62828;
        }

        ul, ol {
            margin: 16px 0;
            padding-left: 24px;
        }

        li {
            margin-bottom: 8px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }

        th, td {
            padding: 14px 16px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background: #f8f8f8;
            font-weight: 600;
            color: #333;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .footer {
            text-align: center;
            padding: 40px 0;
            color: #999;
            font-size: 0.9rem;
            border-top: 1px solid #e0e0e0;
            margin-top: 60px;
        }

        .diagram {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 24px;
            margin: 20px 0;
            font-family: 'Consolas', monospace;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.4;
            font-size: 0.85rem;
        }

        .compare-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        @media (max-width: 600px) {
            .compare-grid {
                grid-template-columns: 1fr;
            }
        }

        .compare-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            border: 1px solid #eee;
        }

        .compare-card h4 {
            font-size: 1.1rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .compare-card.bad h4 {
            color: #d32f2f;
        }

        .compare-card.good h4 {
            color: #388e3c;
        }

        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }

        pre code {
            background: none;
            padding: 0;
        }

        /* 토글 섹션 */
        .toggle-section {
            margin: 16px 0;
        }

        .toggle-section summary {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            cursor: pointer;
            font-weight: 500;
            color: #1e40af;
            background: #dbeafe;
            border-radius: 25px;
            list-style: none;
            transition: all 0.2s;
        }

        .toggle-section summary::-webkit-details-marker {
            display: none;
        }

        .toggle-section summary:hover {
            background: #bfdbfe;
            transform: translateY(-2px);
        }

        .toggle-content {
            margin-top: 12px;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            border: 1px solid #e5e7eb;
            position: relative;
        }

        .toggle-content::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 30px;
            width: 16px;
            height: 16px;
            background: white;
            border-left: 1px solid #e5e7eb;
            border-top: 1px solid #e5e7eb;
            transform: rotate(45deg);
        }

        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            font-weight: 700;
            font-size: 0.9rem;
            margin-right: 10px;
        }

        .architecture-diagram {
            background: #1a1a2e;
            color: #a0a0ff;
            padding: 24px;
            border-radius: 12px;
            font-family: 'Consolas', monospace;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.5;
            font-size: 0.8rem;
        }

        /* 애니메이션 컨테이너 */
        .animation-container {
            background: #1a1a2e;
            border-radius: 16px;
            padding: 30px;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
            min-height: 500px;
        }

        .animation-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s;
        }

        .control-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .control-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .control-btn.secondary {
            background: #2d2d44;
            color: #a0a0a0;
        }

        .control-btn.secondary:hover {
            background: #3d3d5c;
            color: white;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .step-indicator {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .step-dot {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #2d2d44;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .step-dot.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .step-dot.completed {
            background: #4caf50;
            color: white;
        }

        .step-title {
            text-align: center;
            color: #a0a0ff;
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 20px;
            min-height: 30px;
        }

        .animation-stage {
            position: relative;
            height: 350px;
            background: #16162a;
            border-radius: 12px;
            overflow: hidden;
        }

        .server-box {
            position: absolute;
            background: linear-gradient(135deg, #2d2d44 0%, #1e1e32 100%);
            border: 2px solid #3d3d5c;
            border-radius: 12px;
            padding: 15px;
            color: white;
            font-size: 0.85rem;
            transition: all 0.5s ease;
            opacity: 0;
            transform: scale(0.8);
        }

        .server-box.visible {
            opacity: 1;
            transform: scale(1);
        }

        .server-box.highlight {
            border-color: #667eea;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
        }

        .server-box h5 {
            color: #a0a0ff;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .client {
            position: absolute;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            transition: all 0.8s ease;
            opacity: 0;
            z-index: 10;
        }

        .client.visible {
            opacity: 1;
        }

        .client.player2 {
            background: linear-gradient(135deg, #4ecdc4 0%, #3db9b0 100%);
        }

        .packet {
            position: absolute;
            padding: 6px 12px;
            background: #ffd93d;
            color: #333;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
            opacity: 0;
            z-index: 20;
            white-space: nowrap;
        }

        .packet.visible {
            opacity: 1;
        }

        .queue-visual {
            position: absolute;
            background: #2d2d44;
            border: 2px solid #4a4a6a;
            border-radius: 8px;
            padding: 10px;
            transition: all 0.5s ease;
            opacity: 0;
        }

        .queue-visual.visible {
            opacity: 1;
        }

        .queue-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            margin: 3px 0;
            font-size: 0.75rem;
            opacity: 0;
            transform: translateX(-20px);
            transition: all 0.3s ease;
        }

        .queue-item.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .queue-item.matched {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        }

        .match-success {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: 600;
            opacity: 0;
            z-index: 30;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.5);
        }

        .match-success.visible {
            opacity: 1;
            animation: pulse 0.5s ease;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.5); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .step-description {
            color: #b0b0b0;
            text-align: center;
            margin-top: 15px;
            font-size: 0.9rem;
            min-height: 50px;
            padding: 0 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav">
            <a href="../../">&larr; 돌아가기</a>
        </nav>

        <header class="header">
            <h1>매치메이킹 시스템</h1>
            <div class="header-meta">
                <span>Server Architecture</span>
                <span>Redis / Distributed System</span>
            </div>
            <div class="tags">
                <span class="tag">Matchmaking</span>
                <span class="tag">Game Server</span>
                <span class="tag">Redis</span>
                <span class="tag">Queue</span>
                <span class="tag">MMR</span>
            </div>
        </header>

        <!-- 개요 -->
        <section class="section">
            <h2>개요</h2>
            <p>
                온라인 게임에서 "빠른 대전" 버튼을 누르면 비슷한 실력의 상대와 매칭됩니다.
                이 문서는 <strong>질문을 던지고 답을 찾아가는 방식</strong>으로 매치메이킹의 원리를 탐구합니다.
            </p>
        </section>

        <!-- 첫 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">1</span>매칭 요청이 들어오면?</h2>

            <div class="question-box">
                <div class="q-label">첫 번째 질문</div>
                <div class="question">
                    "대전 찾기" 버튼을 누른 순간부터 상대를 만나기까지, 서버에서 어떤 일이 일어나야 할까?
                </div>
            </div>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p>대전 찾기에도 종류가 있다. 레벨별, 지역별, 랭크별 등등.</p>
                <p>내 세션 정보를 기반으로 어딘가 <strong>큐</strong>에 넣어야 할 것 같다.</p>
            </div>

            <div class="answer-box">
                <div class="a-label">핵심 포인트</div>
                <p>맞다! 기본 흐름은 이렇다:</p>
                <div class="diagram">플레이어 → [내 정보: 레벨30, 한국, 골드랭크] → 큐에 등록</div>
            </div>
        </section>

        <!-- 두 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">2</span>큐는 어떻게 설계할까?</h2>

            <div class="question-box">
                <div class="q-label">두 번째 질문</div>
                <div class="question">
                    큐를 여러 개로 나눌까, 하나로 합칠까? 각각의 장단점은?
                </div>
            </div>

            <div class="compare-grid">
                <div class="compare-card">
                    <h4>방법 A: 조건별로 큐 분리</h4>
                    <div class="diagram" style="font-size: 0.8rem; padding: 12px;">[레벨1~10 큐]
[레벨11~20 큐]
[레벨21~30 큐]
    ...
→ 이미 분류됨</div>
                </div>
                <div class="compare-card">
                    <h4>방법 B: 하나의 큐</h4>
                    <div class="diagram" style="font-size: 0.8rem; padding: 12px;">[전체 대기열]
    ↓
꺼낼 때 조건 맞는
사람끼리 묶음</div>
                </div>
            </div>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p>동접자가 많으면 <strong>방법 A가 검색이 빠를 것 같다</strong>.</p>
                <p>이미 분류되어 있으니까, 그냥 해당 큐에서 뽑으면 끝이니까.</p>
            </div>

            <div class="answer-box">
                <div class="a-label">맞다!</div>
                <p>동접자 많으면 A가 빠르다. 이미 분류되어 있으니까:</p>
                <div class="diagram">[골드 랭크 큐] → 여기서 바로 2명 뽑으면 끝!</div>
            </div>
        </section>

        <!-- 세 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">3</span>그런데 조건이 여러 개라면?</h2>

            <div class="question-box">
                <div class="q-label">세 번째 질문</div>
                <div class="question">
                    레벨 + 지역 + 랭크 + 모드... 조건을 조합하면 큐가 몇 개나 필요할까?
                </div>
            </div>

            <div class="diagram">조건 1: 레벨 (1~10, 11~20, 21~30...)  → 10가지
조건 2: 지역 (한국, 일본, 미국...)      → 5가지
조건 3: 랭크 (브론즈, 실버, 골드...)    → 6가지
조건 4: 모드 (솔로, 듀오, 스쿼드)       → 3가지</div>

            <div class="thinking-box">
                <div class="t-label">계산해보면...</div>
                <p><strong>큐가 엄청 많아진다!</strong></p>
                <p>10 × 5 × 6 × 3 = <strong>900개!</strong></p>
            </div>

            <div class="insight-box red">
                <h4>문제 발생!</h4>
                <p>그리고 만약 <strong>[레벨21~30 + 일본 + 다이아 + 스쿼드]</strong> 큐에 사람이 1명뿐이라면?</p>
                <p>→ 이 플레이어는 <strong>영원히 대기</strong>할 수도 있다!</p>
            </div>

            <div class="diagram">[새벽 4시, 다이아 랭크, 일본 서버, 스쿼드]

플레이어: "매칭 대기 중... 10분째..."
→ 결국 게임 끔
→ 유저 이탈</div>
        </section>

        <!-- 네 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">4</span>오래 기다리는 문제를 어떻게 해결할까?</h2>

            <div class="question-box">
                <div class="q-label">네 번째 질문</div>
                <div class="question">
                    한적한 큐에 갇힌 플레이어를 어떻게 구제할 수 있을까?
                </div>
            </div>

            <div class="thinking-box">
                <div class="t-label">힌트: 게임 경험 떠올려보기</div>
                <p>롤이나 오버워치에서 매칭 대기가 길어지면...</p>
                <p>"매칭 범위가 확장됩니다" 같은 메시지가 뜬다!</p>
                <p>→ <strong>조건을 점점 완화</strong>시키면 되지 않을까?</p>
            </div>

            <div class="answer-box">
                <div class="a-label">정답! MMR 범위 확장</div>
                <p>이걸 <strong>조건 완화(Relaxation)</strong>라고 부른다:</p>
            </div>

            <div class="diagram">[0초]   나: 골드1 → 골드1만 찾음
[30초]  나: 골드1 → 골드2~플래티넘4까지 허용
[60초]  나: 골드1 → 실버1~플래티넘2까지 허용
[120초] 나: 골드1 → 거의 아무나...</div>

            <div class="insight-box green">
                <h4>설계 방향 전환!</h4>
                <p>조건별로 큐 900개 만드는 게 아니라:</p>
                <ul>
                    <li>하나의 풀에 모두 등록</li>
                    <li>각 플레이어마다 "대기 시간"에 따라 허용 범위가 넓어짐</li>
                    <li>매칭 시스템이 "누구랑 묶을지" 계산</li>
                </ul>
            </div>
        </section>

        <!-- 다섯 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">5</span>대기열이 1만 명이면 어떻게 찾지?</h2>

            <div class="question-box">
                <div class="q-label">다섯 번째 질문</div>
                <div class="question">
                    대기열에 1만 명이 있을 때, "가장 잘 맞는 상대"를 어떻게 빠르게 찾을까?
                </div>
            </div>

            <div class="thinking-box">
                <div class="t-label">1만 명 전부 비교하면...</div>
                <p>너무 느리다. O(n)은 부담스럽다.</p>
                <p>뭔가 <strong>O(log n)</strong> 정도면 괜찮지 않을까?</p>
                <p>→ 이진 탐색? 정렬된 자료구조?</p>
            </div>

            <div class="answer-box">
                <div class="a-label">좋은 직관!</div>
                <p>실제로 많이 쓰는 방법:</p>
            </div>

            <h3>방법 1: 여러 조건을 하나의 점수(MMR)로 만든다</h3>
            <div class="diagram">플레이어A: 레벨30, 골드, 승률60% → MMR 1,523점
플레이어B: 레벨28, 골드, 승률55% → MMR 1,487점
플레이어C: 레벨35, 실버, 승률70% → MMR 1,510점</div>

            <p>이렇게 하면 MMR 순으로 정렬해서 이진 탐색 가능!</p>

            <div class="diagram">[대기열을 MMR 순으로 정렬]

... → 1,487(B) → 1,510(C) → 1,523(A) → ...
                    ↑
           이진 탐색으로 O(log n)</div>

            <h3>방법 2: 버킷(Bucket)으로 구간 나누기</h3>
            <div class="diagram">[MMR 1000~1100 버킷] → 플레이어 50명
[MMR 1100~1200 버킷] → 플레이어 80명
[MMR 1200~1300 버킷] → 플레이어 120명
              ↑
    내 MMR = 1,150이면 이 버킷에서 바로 검색
    → O(1)로 버킷 접근!</div>
        </section>

        <!-- 여섯 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">6</span>모든 조건을 하나의 점수로 합칠 수 있을까?</h2>

            <div class="question-box">
                <div class="q-label">여섯 번째 질문</div>
                <div class="question">
                    레벨, 랭크, 승률, 지역... 모든 조건을 하나의 MMR로 환산하는 게 항상 가능할까?
                </div>
            </div>

            <div class="thinking-box">
                <div class="t-label">문제점 발견!</div>
                <p>점수가 비슷해도, 어디선가 격차가 크고 다른 데서 상쇄하면...</p>
                <p><strong>점수는 같은데 완전히 다른 유형의 플레이어</strong>가 될 수 있다!</p>
            </div>

            <div class="insight-box red">
                <h4>정보 손실 문제</h4>
                <div class="diagram">플레이어A: 레벨 50 + 브론즈 랭크 → MMR 1,500
플레이어B: 레벨 10 + 다이아 랭크 → MMR 1,500

점수는 같은데... 이 둘이 붙으면?
→ 완전히 다른 유형!</div>
            </div>

            <div class="answer-box">
                <div class="a-label">해결책: 하드 조건 vs 소프트 조건 분리</div>
            </div>

            <div class="diagram">[하드 조건] - 반드시 맞아야 함 (필터링)
├─ 지역 (한국 ↔ 미국은 핑 때문에 불가)
├─ 게임 모드 (솔로 ↔ 스쿼드 불가)
└─ 플랫폼 (PC ↔ 모바일 불가)

[소프트 조건] - 점수로 환산 (스코어링)
├─ MMR/랭크 차이 → 점수화
├─ 레벨 차이 → 점수화
└─ 대기 시간 → 점수화 (오래 기다리면 가산점)</div>

            <h3>매칭 로직 흐름</h3>
            <div class="diagram">1. [하드 필터] 지역=한국, 모드=솔로 → 후보 3,000명
        ↓
2. [스코어링] 각 후보와 "궁합 점수" 계산
        ↓
3. [정렬] 점수 높은 순
        ↓
4. [선택] 상위 1명 매칭</div>
        </section>

        <!-- 일곱 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">7</span>가중치는 누가 정할까?</h2>

            <div class="question-box">
                <div class="q-label">일곱 번째 질문</div>
                <div class="question">
                    MMR 차이 50점은 얼마나 감점? 대기 시간 3분은 얼마나 가점? 이 가중치는 누가, 어떻게 정해야 할까?
                </div>
            </div>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p><strong>기획자</strong>가 정해야 할 것 같다. 게임 밸런스 문제니까.</p>
                <p>그리고 가중치가 잘못되면 <strong>밸런스가 무너진다!</strong></p>
            </div>

            <div class="insight-box red">
                <h4>실제로 일어나는 문제</h4>
                <div class="diagram">기획자: "대기 시간 가중치를 높이자! 빨리 매칭되게!"
    ↓
결과: 3분만 기다리면 브론즈 ↔ 다이아 매칭
    ↓
다이아: "왜 브론즈랑 붙여줌?" (분노)
브론즈: "왜 나만 털림?" (분노)
    ↓
유저 이탈</div>
            </div>

            <div class="answer-box">
                <div class="a-label">해결책: 데이터 기반 튜닝</div>
                <p>대형 게임사는 이렇게 한다:</p>
            </div>

            <div class="diagram">[매칭 후 데이터 수집]
- 매칭된 게임의 승률 분포 (50:50에 가까운가?)
- 유저 만족도 설문
- 게임 중 이탈률
    ↓
[A/B 테스트]
가중치 설정 A vs B 중 어떤 게 더 좋은지 비교
    ↓
[가중치 조정]</div>
        </section>

        <!-- 여덟 번째 질문 -->
        <section class="section">
            <h2><span class="step-number">8</span>서버 구조는 어떻게?</h2>

            <div class="question-box">
                <div class="q-label">여덟 번째 질문</div>
                <div class="question">
                    게임 서버와 매칭 서버를 분리할까, 하나로 합칠까?
                </div>
            </div>

            <div class="thinking-box">
                <div class="t-label">생각해보면...</div>
                <p><strong>분리하는 게 확장성 면에서 좋을 것 같다.</strong></p>
                <p>매칭은 매칭대로, 게임은 게임대로 스케일링할 수 있으니까.</p>
            </div>

            <div class="answer-box">
                <div class="a-label">맞다! 서버 분리가 표준</div>
            </div>

            <div class="architecture-diagram">                         [클라이언트]
                              │
                              ▼
                      ┌──────────────┐
                      │  API Gateway │ (로드밸런서)
                      └──────────────┘
                              │
       ┌──────────────────────┼──────────────────────┐
       ▼                      ▼                      ▼
┌────────────┐        ┌────────────┐        ┌────────────┐
│Auth Server │        │Match Server│        │Game Server │
│   (인증)   │        │   (매칭)   │        │ (게임진행) │
└────────────┘        └────────────┘        └────────────┘
                             │
                   ┌─────────┴─────────┐
                   ▼                   ▼
             ┌──────────┐        ┌──────────┐
             │  Redis   │        │    DB    │
             │ (대기열) │        │(유저정보)│
             └──────────┘        └──────────┘</div>
        </section>

        <!-- 전체 프로세스 시각화 -->
        <section class="section">
            <h2>전체 프로세스 시각화</h2>
            <p>지금까지 배운 내용을 애니메이션으로 확인해보자.</p>

            <div class="animation-container">
                <div class="animation-controls">
                    <button class="control-btn primary" id="playBtn" onclick="playAnimation()">재생</button>
                    <button class="control-btn secondary" id="resetBtn" onclick="resetAnimation()">리셋</button>
                    <button class="control-btn secondary" onclick="prevStep()" id="prevBtn" disabled>이전</button>
                    <button class="control-btn secondary" onclick="nextStep()" id="nextBtn">다음</button>
                </div>

                <div class="step-indicator">
                    <div class="step-dot" id="dot1">1</div>
                    <div class="step-dot" id="dot2">2</div>
                    <div class="step-dot" id="dot3">3</div>
                    <div class="step-dot" id="dot4">4</div>
                    <div class="step-dot" id="dot5">5</div>
                </div>

                <div class="step-title" id="stepTitle">재생 버튼을 눌러보세요</div>

                <div class="animation-stage" id="stage">
                    <div class="client" id="client1" style="left: 30px; top: 140px;">P1</div>
                    <div class="client player2" id="client2" style="left: 30px; top: 220px;">P2</div>

                    <div class="server-box" id="gateway" style="left: 150px; top: 50px; width: 120px;">
                        <h5>API Gateway</h5>
                        <div>Load Balancer</div>
                    </div>

                    <div class="server-box" id="matchServer" style="left: 320px; top: 30px; width: 200px;">
                        <h5>Match Server</h5>
                        <div id="matchServerStatus">대기 중...</div>
                    </div>

                    <div class="queue-visual" id="redisQueue" style="left: 320px; top: 150px; width: 200px; min-height: 100px;">
                        <div style="color: #a0a0ff; font-size: 0.8rem; margin-bottom: 8px;">Redis - 대기 풀 (MMR순)</div>
                        <div id="queueItems"></div>
                    </div>

                    <div class="server-box" id="gameServer" style="left: 580px; top: 140px; width: 150px;">
                        <h5>Game Server</h5>
                        <div id="gameServerStatus">대기 중</div>
                    </div>

                    <div class="packet" id="packet1">매칭 요청</div>
                    <div class="packet" id="packet2">매칭 요청</div>
                    <div class="packet" id="packet3">매칭 완료!</div>

                    <div class="match-success" id="matchSuccess">MATCH FOUND!</div>
                </div>

                <div class="step-description" id="stepDescription">
                    버튼을 누르면 매치메이킹 과정이 단계별로 진행됩니다.
                </div>
            </div>
        </section>

        <!-- 시스템 상세 -->
        <section class="section">
            <h2>시스템 상세 설계</h2>

            <details class="toggle-section">
                <summary>Redis 큐 구조 상세</summary>
                <div class="toggle-content">
                    <h4>대기 풀 개수 기준</h4>
                    <p><strong>하드 조건</strong>만으로 분리한다:</p>
                    <div class="diagram">대기 풀 = 게임모드 수 × 지역 수
예: 3모드(솔로/듀오/스쿼드) × 5지역 = 15개 풀</div>

                    <h4>Redis 키 구조</h4>
                    <table>
                        <tr>
                            <th>키</th>
                            <th>타입</th>
                            <th>용도</th>
                        </tr>
                        <tr>
                            <td>match:pool:solo:kr</td>
                            <td>Sorted Set</td>
                            <td>MMR 기준 정렬된 대기 풀</td>
                        </tr>
                        <tr>
                            <td>match:user:{userId}</td>
                            <td>Hash</td>
                            <td>유저 상태 (waiting/matched)</td>
                        </tr>
                        <tr>
                            <td>match:result:{serverId}</td>
                            <td>List</td>
                            <td>매칭 결과 큐</td>
                        </tr>
                    </table>
                </div>
            </details>

            <details class="toggle-section">
                <summary>매칭 엔진 코드 예시</summary>
                <div class="toggle-content">
                    <p>Tick 기반으로 주기적으로 매칭을 수행한다:</p>
<pre><code>while (running) {
    for (각 대기풀) {
        candidates = 풀에서 후보들 조회

        for (각 후보) {
            // 대기 시간에 따라 허용 범위 계산
            waitTime = now - joinedAt
            mmrRange = baseRange + (waitTime / 30초) × 50

            // 범위 내 상대 탐색 (Redis ZRANGEBYSCORE)
            opponents = ZRANGEBYSCORE(
                pool,
                myMMR - mmrRange,
                myMMR + mmrRange
            )

            if (매칭 가능) {
                createMatch(candidate, opponent)
            }
        }
    }
    sleep(TICK_INTERVAL)  // 보통 1~5초
}</code></pre>
                </div>
            </details>

            <details class="toggle-section">
                <summary>확장성 설계</summary>
                <div class="toggle-content">
                    <h4>Stateless 매칭 서버</h4>
                    <div class="architecture-diagram">┌─────────────────────────────────────┐
│          Redis Cluster              │
│     (대기 풀 - 중앙 집중 관리)       │
└─────────────────────────────────────┘
        ▲       ▲       ▲
        │       │       │
   ┌────┴──┬────┴──┬────┴──┐
   │       │       │       │
┌──────┐┌──────┐┌──────┐┌──────┐
│Match1││Match2││Match3││Match4│ ← Stateless
└──────┘└──────┘└──────┘└──────┘   (무한 확장)</div>
                    <p>상태는 Redis에, 로직만 서버에서 실행 → 수평 확장 가능!</p>
                </div>
            </details>
        </section>

        <!-- 핵심 정리 -->
        <section class="section">
            <h2>핵심 정리</h2>

            <div class="insight-box">
                <h4>우리가 찾은 답들</h4>
                <table>
                    <tr>
                        <th>질문</th>
                        <th>답</th>
                    </tr>
                    <tr>
                        <td>큐를 어떻게 나눌까?</td>
                        <td>하드 조건(지역, 모드)으로만 분리</td>
                    </tr>
                    <tr>
                        <td>조건이 많으면 큐 폭발?</td>
                        <td>소프트 조건은 점수화해서 하나의 풀에서 관리</td>
                    </tr>
                    <tr>
                        <td>오래 기다리면?</td>
                        <td>시간에 따라 매칭 범위 확장 (Relaxation)</td>
                    </tr>
                    <tr>
                        <td>1만 명에서 빠르게 찾기?</td>
                        <td>Sorted Set + 범위 검색 O(log n)</td>
                    </tr>
                    <tr>
                        <td>모든 조건을 점수로?</td>
                        <td>하드/소프트 분리, 하드는 필터, 소프트는 스코어링</td>
                    </tr>
                    <tr>
                        <td>가중치 설정?</td>
                        <td>기획자 + 데이터 기반 A/B 테스트</td>
                    </tr>
                    <tr>
                        <td>서버 구조?</td>
                        <td>매칭/게임 분리, Stateless로 확장성 확보</td>
                    </tr>
                </table>
            </div>
        </section>

        <footer class="footer">
            <p>MSH Portfolio - Server Developer</p>
        </footer>
    </div>

    <script>
        let currentStep = 0;
        let isPlaying = false;
        let animationTimeout = null;

        const steps = [
            {
                title: "STEP 1: 매칭 요청",
                description: "플레이어들이 '대전 찾기'를 누르면, 요청이 API Gateway를 통해 Match Server로 전달된다.",
                action: step1
            },
            {
                title: "STEP 2: 풀 등록",
                description: "Match Server가 유저 정보를 확인하고, Redis 대기 풀에 MMR 순으로 등록한다.",
                action: step2
            },
            {
                title: "STEP 3: 매칭 탐색",
                description: "Tick마다 대기 풀을 스캔. 대기 시간이 길면 MMR 범위가 확장된다.",
                action: step3
            },
            {
                title: "STEP 4: 매칭 완료",
                description: "적합한 상대를 찾으면 양쪽을 풀에서 제거하고 매칭 결과를 생성한다.",
                action: step4
            },
            {
                title: "STEP 5: 게임 시작",
                description: "Game Server가 할당되고, 양쪽 클라이언트가 접속한다. 게임 시작!",
                action: step5
            }
        ];

        function updateStepIndicator() {
            for (let i = 1; i <= 5; i++) {
                const dot = document.getElementById(`dot${i}`);
                dot.classList.remove('active', 'completed');
                if (i < currentStep) {
                    dot.classList.add('completed');
                } else if (i === currentStep) {
                    dot.classList.add('active');
                }
            }
            document.getElementById('prevBtn').disabled = currentStep <= 1;
            document.getElementById('nextBtn').disabled = currentStep >= 5;
        }

        function step1() {
            document.getElementById('client1').classList.add('visible');
            document.getElementById('client2').classList.add('visible');
            document.getElementById('gateway').classList.add('visible');
            document.getElementById('matchServer').classList.add('visible');

            setTimeout(() => {
                const packet1 = document.getElementById('packet1');
                packet1.classList.add('visible');
                packet1.style.left = '100px';
                packet1.style.top = '150px';
                packet1.style.transition = 'all 0.8s ease';
                setTimeout(() => { packet1.style.left = '200px'; packet1.style.top = '80px'; }, 100);
                setTimeout(() => { packet1.style.left = '320px'; packet1.style.top = '50px'; }, 600);
            }, 300);

            setTimeout(() => {
                const packet2 = document.getElementById('packet2');
                packet2.classList.add('visible');
                packet2.style.left = '100px';
                packet2.style.top = '230px';
                packet2.style.transition = 'all 0.8s ease';
                setTimeout(() => { packet2.style.left = '200px'; packet2.style.top = '100px'; }, 100);
                setTimeout(() => { packet2.style.left = '320px'; packet2.style.top = '70px'; }, 600);
            }, 500);

            document.getElementById('gateway').classList.add('highlight');
            setTimeout(() => {
                document.getElementById('matchServer').classList.add('highlight');
                document.getElementById('matchServerStatus').textContent = '요청 수신...';
            }, 800);
        }

        function step2() {
            document.getElementById('redisQueue').classList.add('visible');
            document.getElementById('matchServerStatus').textContent = '풀에 등록 중...';
            const queueItems = document.getElementById('queueItems');

            setTimeout(() => {
                queueItems.innerHTML = '<div class="queue-item" id="qi1">P1: MMR 1523</div>';
                setTimeout(() => document.getElementById('qi1').classList.add('visible'), 100);
            }, 500);

            setTimeout(() => {
                queueItems.innerHTML += '<div class="queue-item" id="qi2">P2: MMR 1487</div>';
                setTimeout(() => document.getElementById('qi2').classList.add('visible'), 100);
            }, 1000);

            setTimeout(() => {
                document.getElementById('packet1').classList.remove('visible');
                document.getElementById('packet2').classList.remove('visible');
            }, 800);

            document.getElementById('redisQueue').classList.add('highlight');
        }

        function step3() {
            document.getElementById('matchServerStatus').textContent = 'Tick... 매칭 탐색 중';
            const qi1 = document.getElementById('qi1');
            const qi2 = document.getElementById('qi2');

            let blinkCount = 0;
            const blinkInterval = setInterval(() => {
                if (blinkCount % 2 === 0) {
                    qi1.style.opacity = '0.5';
                    qi2.style.opacity = '0.5';
                } else {
                    qi1.style.opacity = '1';
                    qi2.style.opacity = '1';
                }
                blinkCount++;
                if (blinkCount > 5) {
                    clearInterval(blinkInterval);
                    qi1.style.opacity = '1';
                    qi2.style.opacity = '1';
                }
            }, 300);

            setTimeout(() => {
                document.getElementById('matchServerStatus').textContent = 'MMR 범위: ±100 확인';
            }, 1000);

            setTimeout(() => {
                document.getElementById('matchServerStatus').textContent = '매칭 대상 발견!';
                qi1.classList.add('matched');
                qi2.classList.add('matched');
            }, 2000);
        }

        function step4() {
            document.getElementById('matchSuccess').classList.add('visible');
            document.getElementById('matchServerStatus').textContent = '매칭 완료!';

            setTimeout(() => {
                document.getElementById('queueItems').innerHTML = '<div style="color: #666; font-size: 0.75rem;">풀 비어있음</div>';
            }, 1000);

            document.getElementById('redisQueue').classList.remove('highlight');
            document.getElementById('matchServer').classList.remove('highlight');
        }

        function step5() {
            document.getElementById('matchSuccess').classList.remove('visible');
            document.getElementById('gameServer').classList.add('visible');
            document.getElementById('gameServer').classList.add('highlight');
            document.getElementById('gameServerStatus').textContent = '게임 시작!';

            setTimeout(() => {
                document.getElementById('client1').style.left = '600px';
                document.getElementById('client1').style.top = '100px';
                document.getElementById('client2').style.left = '600px';
                document.getElementById('client2').style.top = '180px';
            }, 500);

            const packet3 = document.getElementById('packet3');
            packet3.classList.add('visible');
            packet3.style.left = '450px';
            packet3.style.top = '150px';
            packet3.style.background = '#4caf50';
            packet3.style.color = 'white';

            setTimeout(() => { packet3.classList.remove('visible'); }, 2000);
        }

        function goToStep(step) {
            currentStep = step;
            document.getElementById('stepTitle').textContent = steps[step - 1].title;
            document.getElementById('stepDescription').textContent = steps[step - 1].description;
            updateStepIndicator();
            steps[step - 1].action();
        }

        function playAnimation() {
            if (isPlaying) return;
            isPlaying = true;
            document.getElementById('playBtn').disabled = true;
            resetAnimation();

            setTimeout(() => {
                goToStep(1);
                animationTimeout = setTimeout(() => {
                    goToStep(2);
                    animationTimeout = setTimeout(() => {
                        goToStep(3);
                        animationTimeout = setTimeout(() => {
                            goToStep(4);
                            animationTimeout = setTimeout(() => {
                                goToStep(5);
                                isPlaying = false;
                                document.getElementById('playBtn').disabled = false;
                            }, 2500);
                        }, 3000);
                    }, 2000);
                }, 2000);
            }, 500);
        }

        function resetAnimation() {
            if (animationTimeout) clearTimeout(animationTimeout);
            isPlaying = false;
            document.getElementById('playBtn').disabled = false;
            currentStep = 0;

            document.querySelectorAll('.visible').forEach(el => el.classList.remove('visible'));
            document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
            document.querySelectorAll('.matched').forEach(el => el.classList.remove('matched'));

            document.getElementById('client1').style.left = '30px';
            document.getElementById('client1').style.top = '140px';
            document.getElementById('client2').style.left = '30px';
            document.getElementById('client2').style.top = '220px';

            document.getElementById('packet1').style.left = '';
            document.getElementById('packet1').style.top = '';
            document.getElementById('packet2').style.left = '';
            document.getElementById('packet2').style.top = '';
            document.getElementById('packet3').style.left = '';
            document.getElementById('packet3').style.top = '';

            document.getElementById('queueItems').innerHTML = '';
            document.getElementById('matchServerStatus').textContent = '대기 중...';
            document.getElementById('gameServerStatus').textContent = '대기 중';

            document.getElementById('stepTitle').textContent = '재생 버튼을 눌러보세요';
            document.getElementById('stepDescription').textContent = '버튼을 누르면 매치메이킹 과정이 단계별로 진행됩니다.';

            updateStepIndicator();
        }

        function nextStep() {
            if (currentStep < 5) {
                if (currentStep === 0) goToStep(1);
                else goToStep(currentStep + 1);
            }
        }

        function prevStep() {
            if (currentStep > 1) {
                resetAnimation();
                for (let i = 1; i < currentStep; i++) steps[i - 1].action();
                currentStep = currentStep - 1;
                document.getElementById('stepTitle').textContent = steps[currentStep - 1].title;
                document.getElementById('stepDescription').textContent = steps[currentStep - 1].description;
                updateStepIndicator();
            }
        }
    </script>
</body>
</html>
