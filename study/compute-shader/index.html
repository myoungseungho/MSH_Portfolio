<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compute Shader - MSH Portfolio</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.8;
        }
        .container { max-width: 900px; margin: 0 auto; padding: 60px 20px; }
        .back-link {
            display: inline-block;
            margin-bottom: 24px;
            color: #666;
            text-decoration: none;
        }
        .back-link:hover { color: #111; }

        .header { margin-bottom: 48px; }
        .header h1 { font-size: 2.2rem; font-weight: 700; color: #111; margin-bottom: 12px; }
        .header .meta { color: #666; font-size: 0.9rem; }
        .header .tags { margin-top: 12px; }
        .header .tag {
            display: inline-block;
            background: #f0f0f0;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            color: #666;
            margin-right: 8px;
        }
        .header .tag.highlight {
            background: #9C27B0;
            color: white;
        }

        section { margin-bottom: 48px; }
        section h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #111;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid #9C27B0;
        }
        section h3 {
            font-size: 1.2rem;
            font-weight: 600;
            color: #333;
            margin: 28px 0 16px;
        }

        p { margin-bottom: 16px; }

        .concept-box {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            border: 1px solid #eee;
        }
        .concept-box.question {
            border-left: 4px solid #FFC107;
            background: #FFFDE7;
        }
        .concept-box.answer {
            border-left: 4px solid #4CAF50;
            background: #F1F8E9;
        }
        .concept-box.key {
            border-left: 4px solid #9C27B0;
            background: #F3E5F5;
        }
        .concept-box h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: #333;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }
        .comparison-table th, .comparison-table td {
            padding: 14px 16px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        .comparison-table th {
            background: #9C27B0;
            color: white;
            font-weight: 600;
        }
        .comparison-table tr:last-child td { border-bottom: none; }
        .comparison-table tr:hover { background: #fafafa; }

        .code-block {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 20px;
            margin: 16px 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            color: #d4d4d4;
            white-space: pre;
            word-wrap: normal;
        }
        .code-block .comment { color: #6A9955; }
        .code-block .keyword { color: #569CD6; }
        .code-block .type { color: #4EC9B0; }
        .code-block .function { color: #DCDCAA; }
        .code-block .number { color: #B5CEA8; }

        .screenshot {
            width: 100%;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            margin: 20px 0;
        }
        .screenshot-caption {
            text-align: center;
            font-size: 0.85rem;
            color: #666;
            margin-top: 8px;
        }

        .diagram {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 24px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            white-space: pre;
            overflow-x: auto;
        }

        .benchmark-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 16px;
            padding: 32px;
            color: white;
            margin: 24px 0;
        }
        .benchmark-card h3 {
            color: white;
            margin-top: 0;
            font-size: 1.3rem;
        }
        .benchmark-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: 700;
        }
        .stat-label {
            font-size: 0.85rem;
            opacity: 0.9;
        }

        .game-examples {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
            margin: 20px 0;
        }
        .game-example {
            background: white;
            border-radius: 8px;
            padding: 16px;
            border: 1px solid #eee;
        }
        .game-example h4 {
            font-size: 0.95rem;
            margin-bottom: 8px;
            color: #9C27B0;
        }
        .game-example p {
            font-size: 0.85rem;
            color: #666;
            margin: 0;
        }

        .nav-links {
            display: flex;
            justify-content: space-between;
            margin-top: 60px;
            padding-top: 24px;
            border-top: 1px solid #eee;
        }
        .nav-links a {
            color: #9C27B0;
            text-decoration: none;
        }
        .nav-links a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container">
        <a href="../category-gpu/" class="back-link">← GPU / 그래픽스</a>

        <header class="header">
            <h1>Compute Shader</h1>
            <p class="meta">DirectX 11 | GPU 병렬 연산 | 파티클 시스템</p>
            <div class="tags">
                <span class="tag highlight">DirectX 11</span>
                <span class="tag">HLSL</span>
                <span class="tag">병렬 처리</span>
                <span class="tag">성능 최적화</span>
            </div>
        </header>

        <!-- 1. 핵심 개념 -->
        <section>
            <h2>1. Compute Shader란?</h2>

            <div class="concept-box key">
                <h4>핵심 정의</h4>
                <p>Compute Shader는 <strong>렌더링 파이프라인을 거치지 않고</strong> GPU의 병렬 연산 능력만을 활용하는 셰이더입니다. DirectX 11부터 도입되었습니다.</p>
            </div>

            <h3>GPU는 원래 뭘 위해 만들어졌나?</h3>
            <p>GPU는 본래 <strong>렌더링</strong>을 위해 설계되었습니다. 화면에 삼각형을 그리고, 텍스처를 입히고, 조명을 계산하는 작업이죠. 이런 작업들은 공통점이 있습니다:</p>

            <ul style="margin: 16px 0 16px 24px;">
                <li>수백만 개의 픽셀/정점에 대해</li>
                <li>같은 연산을 독립적으로 수행</li>
                <li>각각의 결과가 서로 영향을 주지 않음</li>
            </ul>

            <div class="concept-box question">
                <h4>그런데 개발자들이 생각했습니다</h4>
                <p>"잠깐, GPU가 잘하는 건 결국 <strong>대량의 독립적인 단순 계산</strong>이잖아? 꼭 그림 그리는 데만 써야 해?"</p>
            </div>

            <p>바로 이 아이디어에서 Compute Shader가 탄생했습니다.</p>
        </section>

        <!-- 2. 왜 필요한가 -->
        <section>
            <h2>2. 순차 처리 vs 병렬 처리</h2>

            <h3>어떤 계산이 GPU에 적합할까?</h3>

            <table class="comparison-table">
                <tr>
                    <th>상황</th>
                    <th>특징</th>
                    <th>적합한 처리</th>
                </tr>
                <tr>
                    <td>1부터 100까지 순차 합산</td>
                    <td>이전 결과에 의존 (1+2=3, 3+3=6...)</td>
                    <td><strong>CPU (순차)</strong></td>
                </tr>
                <tr>
                    <td>100만 픽셀에 밝기 1.5배</td>
                    <td>각 픽셀이 독립적, 서로 무관</td>
                    <td><strong>GPU (병렬)</strong></td>
                </tr>
            </table>

            <div class="concept-box answer">
                <h4>핵심 조건</h4>
                <p><strong>"대량의 데이터"</strong>에 <strong>"같은 연산"</strong>을 <strong>"독립적으로"</strong> 적용 → GPU가 압도적으로 유리</p>
            </div>

            <h3>하드웨어 관점에서의 차이</h3>

            <table class="comparison-table">
                <tr>
                    <th>구분</th>
                    <th>CPU</th>
                    <th>GPU</th>
                </tr>
                <tr>
                    <td>코어 수</td>
                    <td>4~16개</td>
                    <td>수천 개</td>
                </tr>
                <tr>
                    <td>각 코어의 특성</td>
                    <td>복잡한 계산에 강함</td>
                    <td>단순 계산에 최적화</td>
                </tr>
                <tr>
                    <td>100만 연산 시</td>
                    <td>코어당 ~6만 개씩 순차 처리</td>
                    <td>코어당 ~250개씩 병렬 처리</td>
                </tr>
            </table>
        </section>

        <!-- 3. 기존 파이프라인과의 차이 -->
        <section>
            <h2>3. 렌더링 파이프라인 vs Compute Shader</h2>

            <h3>기존 렌더링 파이프라인</h3>
            <div class="diagram">정점 데이터 → [버텍스 셰이더] → [래스터화] → [픽셀 셰이더] → 화면 출력

목적: "그림 그리기"
출력: 항상 "픽셀"</div>

            <h3>Compute Shader</h3>
            <div class="diagram">[CPU] → 데이터를 VRAM에 올림 → [GPU 연산만!] → 결과 돌려받음

목적: "범용 계산"
출력: "아무 데이터나"</div>

            <table class="comparison-table">
                <tr>
                    <th>구분</th>
                    <th>기존 렌더링</th>
                    <th>Compute Shader</th>
                </tr>
                <tr>
                    <td>파이프라인</td>
                    <td>정점 → 픽셀 → 화면</td>
                    <td>데이터 → 연산 → 결과</td>
                </tr>
                <tr>
                    <td>목적</td>
                    <td>그림 그리기</td>
                    <td>범용 계산</td>
                </tr>
                <tr>
                    <td>출력</td>
                    <td>픽셀 (고정)</td>
                    <td>아무 데이터나</td>
                </tr>
                <tr>
                    <td>파이프라인 종속</td>
                    <td>O</td>
                    <td>X</td>
                </tr>
            </table>
        </section>

        <!-- 4. 언제 쓰면 안 되는가 -->
        <section>
            <h2>4. Compute Shader가 항상 빠를까?</h2>

            <div class="concept-box question">
                <h4>데이터 전송 오버헤드</h4>
                <p>CPU와 GPU 사이에 데이터가 오고가는 과정에는 비용이 듭니다:</p>
                <ul style="margin-top: 8px;">
                    <li><strong>메모리 전송</strong> (Host ↔ Device)</li>
                    <li><strong>PCIe 대역폭</strong> 제한</li>
                    <li><strong>최소 오버헤드</strong> (택배 기본료처럼)</li>
                </ul>
            </div>

            <div class="diagram">총 시간 = 전송 시간(오버헤드) + 연산 시간

Compute Shader가 이득인 조건:
  GPU 전송 + GPU 연산 < CPU 연산</div>

            <div class="concept-box answer">
                <h4>결론</h4>
                <ul>
                    <li><strong>100개 데이터</strong> 단순 연산 → CPU가 더 빠름</li>
                    <li><strong>10만 개 이상</strong> 데이터 연산 → GPU가 압도적</li>
                    <li>데이터가 충분히 많거나, 연산이 충분히 무거워야 이득</li>
                </ul>
            </div>
        </section>

        <!-- 5. Thread Group -->
        <section>
            <h2>5. Thread Group의 개념</h2>

            <p>GPU의 수천 개 코어가 완전히 제멋대로 돌아가진 않습니다. <strong>Thread Group(Work Group)</strong>으로 묶어서 관리합니다.</p>

            <div class="concept-box">
                <h4>비유: 4000명 직원의 회사</h4>
                <p><strong>CPU 방식:</strong> 16명이 한 사무실에서 칠판 하나 공유</p>
                <p><strong>GPU 방식:</strong> 64명씩 팀으로 나눠서 팀 전용 화이트보드 사용</p>
            </div>

            <div class="code-block">
<span class="comment">// HLSL에서 Thread Group 선언</span>
<span class="comment">// 한 그룹당 256개 스레드</span>
[<span class="keyword">numthreads</span>(<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>)]
<span class="keyword">void</span> <span class="function">CSMain</span>(<span class="type">uint3</span> id : SV_DispatchThreadID)
{
    <span class="comment">// id.x = 이 스레드의 고유 ID (0 ~ 파티클 수-1)</span>
    <span class="keyword">if</span> (id.x >= particleCount) <span class="keyword">return</span>;

    <span class="comment">// 이 스레드가 담당하는 파티클 처리</span>
    Particle p = particles[id.x];
    p.position += p.velocity * deltaTime;
    particles[id.x] = p;
}</div>

            <table class="comparison-table">
                <tr>
                    <th>Thread Group 장점</th>
                    <th>설명</th>
                </tr>
                <tr>
                    <td>Shared Memory</td>
                    <td>그룹 내 빠른 데이터 공유</td>
                </tr>
                <tr>
                    <td>동기화</td>
                    <td>그룹 내 barrier 가능</td>
                </tr>
                <tr>
                    <td>효율적 스케줄링</td>
                    <td>GPU가 그룹 단위로 작업 분배</td>
                </tr>
            </table>
        </section>

        <!-- 6. 게임에서의 활용 -->
        <section>
            <h2>6. 게임에서의 Compute Shader 활용</h2>

            <div class="game-examples">
                <div class="game-example">
                    <h4>파티클 시스템</h4>
                    <p>수만~수십만 파티클 위치/속도 업데이트 (Unreal Niagara, Unity VFX Graph)</p>
                </div>
                <div class="game-example">
                    <h4>GPU 스키닝</h4>
                    <p>캐릭터 뼈대 애니메이션 계산</p>
                </div>
                <div class="game-example">
                    <h4>GPU 컬링</h4>
                    <p>안 보이는 오브젝트 걸러내기 (Assassin's Creed, Horizon)</p>
                </div>
                <div class="game-example">
                    <h4>물리 시뮬레이션</h4>
                    <p>천, 머리카락, 물 시뮬레이션 (TressFX)</p>
                </div>
                <div class="game-example">
                    <h4>포스트 프로세싱</h4>
                    <p>블룸, DOF, 모션 블러</p>
                </div>
                <div class="game-example">
                    <h4>절차적 생성</h4>
                    <p>지형, LOD 계산 (No Man's Sky)</p>
                </div>
            </div>

            <div class="concept-box key">
                <h4>공통점</h4>
                <table class="comparison-table" style="margin: 12px 0 0 0; box-shadow: none;">
                    <tr>
                        <th>작업</th>
                        <th>대상</th>
                        <th>개수</th>
                    </tr>
                    <tr><td>파티클</td><td>점</td><td>7만~10만+</td></tr>
                    <tr><td>헤어</td><td>점</td><td>수만</td></tr>
                    <tr><td>GPU 컬링</td><td>오브젝트</td><td>수만</td></tr>
                    <tr><td>포스트 프로세싱</td><td>픽셀</td><td>수백만</td></tr>
                </table>
                <p style="margin-top: 12px;">전부 <strong>"대량의 독립적 단위에 같은 연산"</strong></p>
            </div>
        </section>

        <!-- 7. 실제 구현 예시 -->
        <section>
            <h2>7. 실제 구현 (파티클 시스템)</h2>

            <h3>Compute Shader 코드 (HLSL)</h3>
            <div class="code-block">
<span class="keyword">struct</span> <span class="type">Particle</span> {
    <span class="type">float3</span> position;
    <span class="type">float</span> life;
    <span class="type">float3</span> velocity;
    <span class="type">float</span> size;
    <span class="type">float4</span> color;
};

<span class="comment">// 읽기/쓰기 가능한 버퍼 (UAV)</span>
<span class="type">RWStructuredBuffer</span>&lt;Particle&gt; particles : <span class="keyword">register</span>(u0);

<span class="keyword">cbuffer</span> Constants : <span class="keyword">register</span>(b0) {
    <span class="type">float</span> deltaTime;
    <span class="type">float</span> totalTime;
    <span class="type">uint</span> particleCount;
};

[<span class="keyword">numthreads</span>(<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>)]
<span class="keyword">void</span> <span class="function">CSMain</span>(<span class="type">uint3</span> id : SV_DispatchThreadID) {
    <span class="keyword">if</span> (id.x >= particleCount) <span class="keyword">return</span>;

    <span class="type">Particle</span> p = particles[id.x];

    <span class="comment">// 수명 감소</span>
    p.life -= deltaTime;

    <span class="comment">// 수명 다하면 리셋</span>
    <span class="keyword">if</span> (p.life <= <span class="number">0.0f</span>) {
        p.position = <span class="type">float3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
        p.life = <span class="number">2.0f</span> + hash(id.x) * <span class="number">3.0f</span>;
    }

    <span class="comment">// 중력 적용</span>
    p.velocity.y -= <span class="number">0.5f</span> * deltaTime;

    <span class="comment">// 위치 업데이트</span>
    p.position += p.velocity * deltaTime;

    <span class="comment">// 결과 저장</span>
    particles[id.x] = p;
}</div>

            <h3>C++에서 Dispatch 호출</h3>
            <div class="code-block">
<span class="comment">// Compute Shader 바인딩</span>
context->CSSetShader(computeShader, <span class="keyword">nullptr</span>, <span class="number">0</span>);
context->CSSetConstantBuffers(<span class="number">0</span>, <span class="number">1</span>, &constantBuffer);
context->CSSetUnorderedAccessViews(<span class="number">0</span>, <span class="number">1</span>, &particleUAV, <span class="keyword">nullptr</span>);

<span class="comment">// 디스패치 (256 스레드씩 그룹)</span>
<span class="type">UINT</span> threadGroups = (particleCount + <span class="number">255</span>) / <span class="number">256</span>;
context-><span class="function">Dispatch</span>(threadGroups, <span class="number">1</span>, <span class="number">1</span>);

<span class="comment">// 10만 파티클 → 391개 Thread Group 실행</span>
<span class="comment">// 각 그룹에서 256개 스레드가 병렬 실행</span></div>
        </section>

        <!-- 8. 실행 데모 -->
        <section>
            <h2>8. 실행 데모</h2>
            <p>10만 개의 파티클이 중앙에서 폭발하듯 퍼져나가는 시뮬레이션입니다. GPU (Compute Shader) 모드에서 실시간으로 부드럽게 동작합니다.</p>
            <img src="demo.gif" alt="Compute Shader 파티클 데모" class="screenshot">
            <p class="screenshot-caption">GPU 모드 (Compute Shader) - 10만 파티클 실시간 시뮬레이션</p>
        </section>

        <!-- 9. 성능 비교 -->
        <section>
            <h2>9. CPU vs GPU 성능 비교</h2>

            <div class="benchmark-card">
                <h3>파티클 10만 개 업데이트 벤치마크</h3>
                <p style="opacity: 0.9; margin-bottom: 0;">매 프레임 위치, 속도, 수명 계산</p>
                <div class="benchmark-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="cpuTime">-</div>
                        <div class="stat-label">CPU 평균 (ms)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="gpuTime">-</div>
                        <div class="stat-label">GPU 평균 (ms)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="speedup">-</div>
                        <div class="stat-label">속도 향상</div>
                    </div>
                </div>
            </div>

            <div class="concept-box">
                <h4>테스트 환경</h4>
                <ul id="testEnv">
                    <li>GPU: (벤치마크 실행 후 표시)</li>
                    <li>파티클 수: 100,000개</li>
                    <li>측정 프레임: 300 프레임</li>
                </ul>
            </div>

            <div class="concept-box answer">
                <h4>결론</h4>
                <p>대량의 독립적인 연산에서 Compute Shader(GPU)는 CPU 대비 <strong id="conclusionSpeedup">수십 배</strong> 빠릅니다. 게임에서 파티클, 물리, 컬링 등에 Compute Shader를 사용하는 이유가 바로 이것입니다.</p>
            </div>
        </section>

        <!-- 10. 핵심 요약 -->
        <section>
            <h2>10. 핵심 요약</h2>

            <div class="concept-box key">
                <ol style="margin-left: 20px;">
                    <li style="margin-bottom: 12px;"><strong>GPU는 대량의 독립적 단순 연산에 강함</strong><br>수천 개 코어가 동시에 같은 작업 수행</li>
                    <li style="margin-bottom: 12px;"><strong>Compute Shader는 렌더링 없이 GPU 연산만 사용</strong><br>파이프라인 우회, 범용 계산 가능</li>
                    <li style="margin-bottom: 12px;"><strong>데이터 전송 오버헤드 고려 필요</strong><br>데이터가 적으면 CPU가 더 유리할 수 있음</li>
                    <li style="margin-bottom: 12px;"><strong>Thread Group으로 효율적 관리</strong><br>그룹 내 공유 메모리와 동기화 지원</li>
                    <li><strong>게임에서 필수적인 기술</strong><br>파티클, 물리, 컬링, 포스트 프로세싱 등</li>
                </ol>
            </div>
        </section>

        <div class="nav-links">
            <a href="../category-gpu/">← GPU / 그래픽스 목록</a>
            <a href="../../">메인으로 →</a>
        </div>
    </div>

    <script>
        // 실제 벤치마크 결과 (2026-01-12 측정)
        const benchmarkData = {
            gpu: "NVIDIA GeForce RTX 4070 Ti",
            particle_count: 100000,
            benchmark_frames: 300,
            cpu_avg: 1.536,
            cpu_min: 0.96,
            cpu_max: 2.88,
            cpu_median: 1.39,
            gpu_avg: 0.0123,
            gpu_min: 0.0035,
            gpu_max: 0.12,
            gpu_median: 0.0107,
            speedup: 125.0
        };

        document.getElementById('cpuTime').textContent = benchmarkData.cpu_avg.toFixed(2);
        document.getElementById('gpuTime').textContent = benchmarkData.gpu_avg.toFixed(3);
        document.getElementById('speedup').textContent = benchmarkData.speedup.toFixed(0) + 'x';
        document.getElementById('conclusionSpeedup').textContent = Math.round(benchmarkData.speedup) + '배';

        // 테스트 환경 업데이트
        document.getElementById('testEnv').innerHTML = `
            <li>GPU: ${benchmarkData.gpu}</li>
            <li>파티클 수: ${benchmarkData.particle_count.toLocaleString()}개</li>
            <li>측정 프레임: ${benchmarkData.benchmark_frames} 프레임 (워밍업 60프레임 제외)</li>
            <li>CPU: 평균 ${benchmarkData.cpu_avg.toFixed(2)}ms (min: ${benchmarkData.cpu_min}ms, max: ${benchmarkData.cpu_max.toFixed(2)}ms)</li>
            <li>GPU: 평균 ${benchmarkData.gpu_avg.toFixed(3)}ms (min: ${benchmarkData.gpu_min}ms, max: ${benchmarkData.gpu_max.toFixed(2)}ms)</li>
        `;
    </script>
</body>
</html>
